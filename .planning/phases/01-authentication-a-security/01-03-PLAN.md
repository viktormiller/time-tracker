---
phase: 01-authentication-a-security
plan: 03
type: execute
wave: 3
depends_on: ["01-02"]
files_modified:
  - backend/src/server.ts
  - frontend/src/App.tsx
  - frontend/src/lib/auth.ts
  - frontend/src/components/LoginForm.tsx
autonomous: true

must_haves:
  truths:
    - "All existing API routes require authentication"
    - "Unauthenticated API requests return 401"
    - "Frontend shows login form when not authenticated"
    - "Frontend stores access token in memory (not localStorage)"
    - "Frontend automatically refreshes expired access tokens"
    - "Frontend can logout and clear auth state"
  artifacts:
    - path: "backend/src/server.ts"
      provides: "Protected API routes"
      contains: "preHandler.*authenticate"
    - path: "frontend/src/lib/auth.ts"
      provides: "Auth state management and token handling"
      min_lines: 80
      exports: ["useAuth", "AuthProvider"]
    - path: "frontend/src/components/LoginForm.tsx"
      provides: "Login UI component"
      min_lines: 60
      exports: ["default"]
    - path: "frontend/src/App.tsx"
      provides: "Auth-aware application wrapper"
      contains: "AuthProvider"
  key_links:
    - from: "frontend/src/lib/auth.ts"
      to: "/api/auth/login"
      via: "fetch in login function"
      pattern: "fetch.*auth/login"
    - from: "frontend/src/lib/auth.ts"
      to: "/api/auth/refresh"
      via: "axios interceptor for 401"
      pattern: "refresh.*interceptor|401"
    - from: "backend/src/server.ts"
      to: "fastify.authenticate"
      via: "preHandler on protected routes"
      pattern: "preHandler.*authenticate"
---

<objective>
Protect existing API routes with authentication and create frontend login UI with auth state management.

Purpose: Completes the authentication flow by requiring auth for all API access and providing users a login interface.

Output: Backend API fully protected, frontend with login form and automatic token refresh handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-authentication-a-security/01-RESEARCH.md
@.planning/phases/01-authentication-a-security/01-02-SUMMARY.md
@backend/src/server.ts
@backend/src/routes/auth.routes.ts
@frontend/src/App.tsx
</context>

<tasks>

<task type="auto">
  <name>Protect existing API routes</name>
  <files>backend/src/server.ts</files>
  <action>
Wrap existing API routes in protected plugin to require authentication:

Replace current individual route definitions with plugin-based grouping:

```typescript
// Protected API routes (from RESEARCH.md lines 728-740)
app.register(async (protectedRoutes) => {
  // Apply authentication to ALL routes in this plugin
  protectedRoutes.addHook('onRequest', app.authenticate);

  // Move existing routes into this plugin:
  protectedRoutes.get('/stats', async (request, reply) => {
    const entries = await prisma.timeEntry.findMany({
      orderBy: { date: 'desc' }
    });
    return entries;
  });

  protectedRoutes.post('/upload', async (req, reply) => {
    // existing upload logic
  });

  protectedRoutes.post('/sync/toggl', async (req, reply) => {
    // existing sync logic
  });

  protectedRoutes.post('/sync/tempo', async (req, reply) => {
    // existing sync logic
  });

  protectedRoutes.put('/entries/:id', async (req, reply) => {
    // existing edit logic
  });

  protectedRoutes.delete('/entries/:id', async (req, reply) => {
    // existing delete logic
  });

}, { prefix: '/api' });
```

Pattern from RESEARCH.md lines 512-518.

All routes inside this plugin are automatically protected. Auth routes remain outside (still public).

DO NOT use global onRequest hook (Pitfall 4 - would protect login route).
DO NOT add individual preHandler to each route (use plugin-level hook instead).
  </action>
  <verify>
Run:
```bash
cd backend
npm run dev &
sleep 3
# Should fail with 401
curl http://localhost:3000/api/stats -w "\nHTTP Status: %{http_code}\n"
# Should succeed (auth route is public)
curl -X POST http://localhost:3000/api/auth/login \
  -H "Content-Type: application/json" \
  -d '{"username":"test","password":"test"}' \
  -w "\nHTTP Status: %{http_code}\n"
pkill -f "node.*server"
```

/api/stats should return 401. /api/auth/login should return 401 (invalid creds) but route is accessible.
  </verify>
  <done>
All existing API routes moved into protected plugin. Routes require valid JWT. Auth routes remain public. Unauthenticated requests return 401.
  </done>
</task>

<task type="auto">
  <name>Create frontend auth state management</name>
  <files>frontend/src/lib/auth.ts</files>
  <action>
Create auth.ts with React Context + hooks for auth state:

**AuthContext:**
- user: { userId: number, role: string } | null
- accessToken: string | null (stored in memory ONLY - not localStorage, Pitfall from RESEARCH.md)
- login(username, password): Promise<void>
- logout(): Promise<void>
- isAuthenticated: boolean

**AuthProvider component:**
- Manages auth state with useState
- login() function: POST to /api/auth/login, store accessToken in memory
- logout() function: POST to /api/auth/logout, clear accessToken
- Provides context to children

**useAuth() hook:**
- Returns context value
- Throws error if used outside AuthProvider

**Axios interceptor for automatic token refresh:**
- Intercept 401 responses
- Try POST to /api/auth/refresh (uses HttpOnly cookie)
- If refresh succeeds: retry original request with new token
- If refresh fails: logout user

Pattern: Standard React Context + axios interceptors for token management.

Store access token in memory (component state), NOT localStorage (XSS protection).
Refresh token stored in HttpOnly cookie (set by backend, inaccessible to JS).

DO NOT store tokens in localStorage (RESEARCH.md warns against this).
DO refresh tokens automatically on 401 (seamless UX).
  </action>
  <verify>
Run:
```bash
cd frontend
npx tsc --noEmit
grep "createContext" src/lib/auth.ts
grep "interceptors" src/lib/auth.ts
grep "refresh" src/lib/auth.ts
```

File should compile and contain context, provider, and interceptor logic.
  </verify>
  <done>
auth.ts created with AuthContext, AuthProvider, useAuth hook, and axios 401 interceptor for automatic token refresh. Access token stored in memory only.
  </done>
</task>

<task type="auto">
  <name>Create login form and integrate auth</name>
  <files>
frontend/src/components/LoginForm.tsx
frontend/src/App.tsx
  </files>
  <action>
**1. Create frontend/src/components/LoginForm.tsx:**

Simple login form component:
- Two input fields: username (text), password (password type)
- Submit button
- Error message display for failed login
- Loading state during submission
- Uses useAuth() hook to call login()
- On successful login: AuthProvider updates state, App.tsx shows dashboard

Style with Tailwind (existing pattern in App.tsx):
- Center on screen
- Card-style container
- Focus styles on inputs
- Disabled state on submit button during loading

**2. Update frontend/src/App.tsx:**

Wrap entire application in AuthProvider:
```tsx
import { AuthProvider, useAuth } from './lib/auth';
import LoginForm from './components/LoginForm';

function App() {
  return (
    <AuthProvider>
      <AppContent />
    </AuthProvider>
  );
}

function AppContent() {
  const { isAuthenticated } = useAuth();

  if (!isAuthenticated) {
    return <LoginForm />;
  }

  // Existing dashboard UI remains here
  return (
    <div className="App">
      {/* existing dashboard code */}
    </div>
  );
}
```

Add logout button to existing dashboard header (use useAuth().logout()).

DO NOT store access token in localStorage.
DO show login form when isAuthenticated is false.
DO preserve existing dashboard UI when authenticated.
  </action>
  <verify>
Run:
```bash
cd frontend
npx tsc --noEmit
npm run dev &
sleep 3
curl http://localhost:5173 | grep -i "login"
pkill -f vite
```

Should see login form in HTML output. TypeScript should compile without errors.
  </verify>
  <done>
LoginForm.tsx created with username/password inputs. App.tsx wrapped in AuthProvider. Dashboard conditionally rendered based on auth state. Logout button added to header.
  </done>
</task>

</tasks>

<verification>
1. Start backend: `cd backend && npm run dev`
2. Start frontend: `cd frontend && npm run dev`
3. Visit http://localhost:5173 - should see login form
4. Try accessing /api/stats directly - should get 401
5. Check TypeScript compilation: `npx tsc --noEmit` in both frontend/ and backend/
</verification>

<success_criteria>
- All API routes protected with authentication middleware
- Unauthenticated API requests return 401
- Frontend shows login form when not authenticated
- Auth state managed via React Context (not localStorage)
- Automatic token refresh on 401 responses
- Logout functionality clears auth state and cookies
- TypeScript compiles without errors in both frontend and backend
</success_criteria>

<output>
After completion, create `.planning/phases/01-authentication-a-security/01-03-SUMMARY.md`
</output>
