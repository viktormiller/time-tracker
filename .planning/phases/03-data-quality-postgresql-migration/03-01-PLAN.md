---
phase: 03-data-quality-postgresql-migration
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/prisma/schema.prisma
  - backend/scripts/migrate-sqlite-to-pg.sh
  - backend/scripts/validate-migration.ts
  - backend/package.json
autonomous: true

must_haves:
  truths:
    - "PostgreSQL schema uses TIMESTAMPTZ for all DateTime fields"
    - "UUID IDs are generated at database level with gen_random_uuid()"
    - "Migration script can transfer SQLite data to PostgreSQL"
    - "Migration validation confirms data integrity"
  artifacts:
    - path: "backend/prisma/schema.prisma"
      provides: "Updated schema with TIMESTAMPTZ and database-level UUID generation"
      contains: "db.Timestamptz"
    - path: "backend/scripts/migrate-sqlite-to-pg.sh"
      provides: "pgloader migration script for SQLite to PostgreSQL"
      min_lines: 15
    - path: "backend/scripts/validate-migration.ts"
      provides: "Post-migration validation script"
      exports: ["validateMigration"]
  key_links:
    - from: "backend/prisma/schema.prisma"
      to: "PostgreSQL database"
      via: "prisma migrate deploy"
      pattern: "gen_random_uuid"
---

<objective>
Update Prisma schema to use PostgreSQL-native TIMESTAMPTZ for timezone-aware timestamps and database-level UUID generation. Create migration infrastructure for SQLite to PostgreSQL data transfer.

Purpose: Establish production-ready database schema with proper timezone handling and collision-resistant IDs before data migration.
Output: Updated schema, migration script (pgloader), validation script
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-quality-postgresql-migration/03-CONTEXT.md
@.planning/phases/03-data-quality-postgresql-migration/03-RESEARCH.md

@backend/prisma/schema.prisma
@docker-compose.yml
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Prisma Schema for PostgreSQL Features</name>
  <files>backend/prisma/schema.prisma</files>
  <action>
Update the TimeEntry model in schema.prisma:

1. Change `id` field to use database-level UUID generation:
   ```prisma
   id String @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
   ```

2. Update DateTime fields to use TIMESTAMPTZ with microsecond precision:
   ```prisma
   date      DateTime @db.Timestamptz(6)
   createdAt DateTime @default(now()) @db.Timestamptz(6)
   ```

3. Keep existing unique constraint and index unchanged.

4. Create new Prisma migration:
   ```bash
   cd backend && npx prisma migrate dev --name add_timestamptz_and_db_uuid
   ```

Note: PostgreSQL 17 (used in docker-compose.yml) has gen_random_uuid() built-in, no pgcrypto extension needed.
  </action>
  <verify>
Run `npx prisma validate` in backend directory - should pass without errors.
Run `npx prisma migrate status` - should show migration applied.
  </verify>
  <done>Schema uses @db.Timestamptz(6) for date/createdAt fields and dbgenerated("gen_random_uuid()") @db.Uuid for id field</done>
</task>

<task type="auto">
  <name>Task 2: Create SQLite to PostgreSQL Migration Script</name>
  <files>backend/scripts/migrate-sqlite-to-pg.sh</files>
  <action>
Create a shell script that uses pgloader to migrate data from SQLite to PostgreSQL.

The script should:
1. Check for required environment variables (DATABASE_URL, SQLITE_PATH)
2. Stop the application if running (maintenance window approach)
3. Create pgloader configuration file with:
   - Source: SQLite database file
   - Target: PostgreSQL from DATABASE_URL
   - Type casting for integers to booleans
   - UTF-8 encoding
4. Run pgloader with the configuration
5. Backup original SQLite file (rename to dev.db.backup)
6. Run validation script after migration

Script structure:
```bash
#!/bin/bash
set -e

# Configuration
SQLITE_PATH="${SQLITE_PATH:-./backend/dev.db}"
DATABASE_URL="${DATABASE_URL:?DATABASE_URL environment variable required}"

# Parse PostgreSQL URL components
# ... extract host, port, user, password, database from DATABASE_URL

# Create pgloader config
cat > /tmp/migrate.load << EOF
LOAD DATABASE
  FROM sqlite://${SQLITE_PATH}
  INTO ${DATABASE_URL}

WITH include drop, create tables, create indexes, reset sequences

SET work_mem to '256MB', maintenance_work_mem to '512MB'

CAST type integer when (= precision 1) to boolean drop typemod;
EOF

# Run migration
echo "Starting migration..."
pgloader /tmp/migrate.load

# Backup SQLite file
mv "${SQLITE_PATH}" "${SQLITE_PATH}.backup"
echo "SQLite backup created at ${SQLITE_PATH}.backup"

# Run validation
npx ts-node ./backend/scripts/validate-migration.ts
```

Mark script as executable: chmod +x backend/scripts/migrate-sqlite-to-pg.sh
  </action>
  <verify>
Run `bash -n backend/scripts/migrate-sqlite-to-pg.sh` to check syntax.
Run `ls -la backend/scripts/migrate-sqlite-to-pg.sh` - should show executable permission.
  </verify>
  <done>Migration script exists at backend/scripts/migrate-sqlite-to-pg.sh with pgloader configuration for SQLite to PostgreSQL transfer</done>
</task>

<task type="auto">
  <name>Task 3: Create Migration Validation Script</name>
  <files>backend/scripts/validate-migration.ts, backend/package.json</files>
  <action>
Create TypeScript validation script that verifies migration success.

The script should:
1. Connect to PostgreSQL using Prisma
2. Count total entries and compare to expected count (if provided via env)
3. Check for null IDs (should be zero with UUID generation)
4. Verify no duplicate source+externalId combinations
5. Sample latest entries to confirm data integrity
6. Output clear pass/fail status

```typescript
// backend/scripts/validate-migration.ts
import { PrismaClient } from '@prisma/client';

async function validateMigration() {
  const prisma = new PrismaClient();

  try {
    console.log('Starting migration validation...\n');

    // 1. Count total entries
    const totalEntries = await prisma.timeEntry.count();
    console.log(`Total entries: ${totalEntries}`);

    // Compare to expected if provided
    const expectedCount = process.env.EXPECTED_COUNT
      ? parseInt(process.env.EXPECTED_COUNT, 10)
      : null;
    if (expectedCount !== null) {
      if (totalEntries !== expectedCount) {
        throw new Error(`Count mismatch: expected ${expectedCount}, got ${totalEntries}`);
      }
      console.log(`  Count matches expected: ${expectedCount}`);
    }

    // 2. Check for null IDs
    const nullIds = await prisma.timeEntry.count({
      where: { id: { equals: null as any } }
    });
    console.log(`\nEntries with null IDs: ${nullIds}`);
    if (nullIds > 0) {
      throw new Error(`Found ${nullIds} entries with null IDs`);
    }

    // 3. Check for duplicates
    const duplicates = await prisma.$queryRaw<{count: bigint}[]>`
      SELECT COUNT(*) as count FROM (
        SELECT source, "externalId"
        FROM "TimeEntry"
        WHERE "externalId" IS NOT NULL
        GROUP BY source, "externalId"
        HAVING COUNT(*) > 1
      ) as dupes
    `;
    const dupeCount = Number(duplicates[0]?.count || 0);
    console.log(`Duplicate source+externalId combinations: ${dupeCount}`);
    if (dupeCount > 0) {
      throw new Error(`Found ${dupeCount} duplicate entries`);
    }

    // 4. Sample recent entries
    const samples = await prisma.timeEntry.findMany({
      take: 3,
      orderBy: { createdAt: 'desc' }
    });
    console.log('\nLatest entries sample:');
    samples.forEach((entry, i) => {
      console.log(`  ${i + 1}. [${entry.source}] ${entry.project} - ${entry.duration}h on ${entry.date.toISOString()}`);
    });

    // 5. Verify UUID format for IDs
    const uuidRegex = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
    const invalidUuids = samples.filter(e => !uuidRegex.test(e.id));
    if (invalidUuids.length > 0) {
      console.log(`\nWarning: Some IDs are not UUID format (may be legacy data)`);
    }

    console.log('\n========================================');
    console.log('VALIDATION PASSED');
    console.log('========================================');

    process.exit(0);
  } catch (error) {
    console.error('\n========================================');
    console.error('VALIDATION FAILED');
    console.error('========================================');
    console.error(error);
    process.exit(1);
  } finally {
    await prisma.$disconnect();
  }
}

validateMigration();
```

Add script to package.json:
```json
"scripts": {
  "validate-migration": "ts-node scripts/validate-migration.ts"
}
```

Ensure ts-node is available (already a dev dependency).
  </action>
  <verify>
Run `cd backend && npx ts-node scripts/validate-migration.ts` against running PostgreSQL (requires DATABASE_URL set).
Should output validation results and exit with code 0 on success.
  </verify>
  <done>Validation script checks entry count, null IDs, duplicates, and samples data; outputs VALIDATION PASSED/FAILED status</done>
</task>

</tasks>

<verification>
1. `cd backend && npx prisma validate` - Schema is valid
2. `cd backend && npx prisma migrate status` - Migration applied
3. `bash -n backend/scripts/migrate-sqlite-to-pg.sh` - Script syntax valid
4. Docker stack running: `cd backend && DATABASE_URL=postgresql://... npx ts-node scripts/validate-migration.ts` - Validation passes
</verification>

<success_criteria>
- Prisma schema updated with TIMESTAMPTZ and database-level UUID generation
- Migration script ready to transfer SQLite data to PostgreSQL
- Validation script confirms data integrity post-migration
- All scripts executable and tested
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-quality-postgresql-migration/03-01-SUMMARY.md`
</output>
