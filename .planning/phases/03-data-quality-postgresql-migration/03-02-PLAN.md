---
phase: 03-data-quality-postgresql-migration
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/src/services/tempo.service.ts
  - backend/.env.example
  - docker-compose.yml
autonomous: true

must_haves:
  truths:
    - "Tempo entries display Jira issue keys (e.g., ABC-27) instead of Issue #ID"
    - "Issue keys are extracted from Tempo API response (issue.key field)"
    - "JIRA_BASE_URL environment variable is configurable"
    - "Duplicate sync operations fail with clear error message (not silently skip)"
  artifacts:
    - path: "backend/src/services/tempo.service.ts"
      provides: "Updated Tempo service with issue key extraction and collision handling"
      contains: "issue.key"
    - path: "backend/.env.example"
      provides: "Environment variable documentation including JIRA_BASE_URL"
      contains: "JIRA_BASE_URL"
  key_links:
    - from: "backend/src/services/tempo.service.ts"
      to: "TimeEntry.project"
      via: "issueKey assignment"
      pattern: "entry\\.issue\\?\\.key"
---

<objective>
Enhance Tempo service to extract and display readable Jira issue keys from API responses. Add JIRA_BASE_URL configuration for clickable links. Implement strict collision handling that fails on duplicates.

Purpose: Improve data quality by showing meaningful issue identifiers and preventing silent data corruption from duplicate entries.
Output: Updated Tempo service with issue key display and proper error handling
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-data-quality-postgresql-migration/03-CONTEXT.md
@.planning/phases/03-data-quality-postgresql-migration/03-RESEARCH.md

@backend/src/services/tempo.service.ts
@backend/src/server.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update Tempo Service for Issue Key Display</name>
  <files>backend/src/services/tempo.service.ts</files>
  <action>
Update the Tempo service to properly extract issue keys from API responses and format them for display.

Changes required:

1. Update issue key extraction logic to prioritize issue.key from Tempo API response:
   ```typescript
   // The Tempo API v4 response includes issue.key when available
   // Format: "ABC-27 - Project Name" for display in project column
   let issueKey = 'Unknown Issue';
   let projectName = '';

   if (entry.issue?.key) {
     issueKey = entry.issue.key;
     // If we also have project info, combine them
     if (entry.issue.project?.name) {
       projectName = entry.issue.project.name;
     }
   } else if (entry.issue?.id) {
     issueKey = `Issue #${entry.issue.id}`;
   }

   // Format for project column: "ABC-27 - Project Name" or just "ABC-27"
   const projectDisplay = projectName
     ? `${issueKey} - ${projectName}`
     : issueKey;
   ```

2. Add try-catch around upsert with strict collision handling:
   ```typescript
   try {
     await this.prisma.timeEntry.upsert({
       where: {
         source_externalId: {
           source: 'TEMPO',
           externalId: entry.tempoWorklogId.toString()
         }
       },
       update: { /* ... */ },
       create: { /* ... */ }
     });
     count++;
   } catch (error: any) {
     if (error.code === 'P2002') {
       // Unique constraint violation - fail the operation
       const errMsg = `Duplicate entry detected: TEMPO/${entry.tempoWorklogId}. ` +
         `Issue: ${issueKey}, Date: ${entry.startDate}`;
       console.error('[Tempo Sync Error]', errMsg);
       throw new Error(errMsg);
     }
     throw error;
   }
   ```

3. Add detailed logging for debugging issue key resolution:
   ```typescript
   if (entry.issue?.key) {
     console.log(`[Tempo] Entry ${entry.tempoWorklogId}: Using issue key ${entry.issue.key}`);
   } else {
     console.log(`[Tempo] Entry ${entry.tempoWorklogId}: No key found, using ID ${entry.issue?.id}`);
   }
   ```

4. Return additional metadata in sync result:
   ```typescript
   return {
     count,
     cached: usedCache,
     message: usedCache ? 'Geladen aus Cache' : 'Frisch von Tempo API geladen',
     issueKeysResolved: entriesWithKeys,
     issueKeysFallback: entriesWithFallback
   };
   ```
  </action>
  <verify>
Review tempo.service.ts to confirm:
- issue.key is used when available
- Project display format is "KEY - Name" or just "KEY"
- P2002 error causes sync to fail with descriptive message
- Logging added for issue key resolution
  </verify>
  <done>Tempo service extracts issue.key from API responses, displays in "ABC-27 - Project Name" format, and fails on duplicate collisions with clear error messages</done>
</task>

<task type="auto">
  <name>Task 2: Add JIRA_BASE_URL Configuration</name>
  <files>backend/.env.example, docker-compose.yml</files>
  <action>
Add JIRA_BASE_URL environment variable for generating clickable Jira links.

1. Update backend/.env.example (create if not exists):
   ```
   # Time Tracker Backend Configuration

   # Database
   DATABASE_URL=postgresql://user:password@localhost:5432/timetracker

   # API Tokens (from provider dashboards)
   TEMPO_API_TOKEN=your_tempo_api_token_here
   TOGGL_API_TOKEN=your_toggl_api_token_here

   # Jira Configuration (for clickable issue links)
   # Example: https://yourcompany.atlassian.net
   JIRA_BASE_URL=https://your-jira-instance.atlassian.net

   # Auth secrets (generate with: openssl rand -base64 64)
   JWT_SECRET=your_jwt_secret_here
   SESSION_SECRET=your_32_byte_session_secret_here
   ADMIN_PASSWORD_HASH=your_bcrypt_hash_here
   ```

2. Update docker-compose.yml to pass JIRA_BASE_URL to backend:
   In the backend service environment section, add:
   ```yaml
   environment:
     - JIRA_BASE_URL=${JIRA_BASE_URL:-}
   ```

   Or if using secrets pattern already, keep env var approach since JIRA_BASE_URL is not sensitive.

3. Update Tempo service to export the base URL for frontend consumption:
   In the sync response, include the configured base URL:
   ```typescript
   jiraBaseUrl: process.env.JIRA_BASE_URL || null
   ```

   This allows frontend to construct clickable links without hardcoding.
  </action>
  <verify>
Check backend/.env.example includes JIRA_BASE_URL with example value.
Check docker-compose.yml passes JIRA_BASE_URL to backend service.
  </verify>
  <done>JIRA_BASE_URL environment variable documented and passed through Docker Compose for generating clickable issue links</done>
</task>

<task type="auto">
  <name>Task 3: Add API Endpoint for Jira Configuration</name>
  <files>backend/src/server.ts</files>
  <action>
Add an endpoint that returns Jira configuration for frontend use.

Add to protected routes in server.ts:

```typescript
// Get Jira configuration for frontend
protectedRoutes.get('/config/jira', async (request, reply) => {
  return {
    baseUrl: process.env.JIRA_BASE_URL || null,
    configured: !!process.env.JIRA_BASE_URL
  };
});
```

This endpoint:
- Is protected (requires authentication)
- Returns JIRA_BASE_URL if configured
- Returns configured: false if not set (frontend can hide link functionality)

Note: This is a simple pattern - could be expanded to /config for all frontend-relevant settings later.
  </action>
  <verify>
Start backend and curl the endpoint:
`curl -X GET http://localhost:3000/api/config/jira -H "Authorization: Bearer $TOKEN"`
Should return JSON with baseUrl and configured fields.
  </verify>
  <done>API endpoint /api/config/jira returns Jira base URL for frontend link generation</done>
</task>

</tasks>

<verification>
1. Review tempo.service.ts - uses entry.issue?.key for display
2. Review tempo.service.ts - catches P2002 and throws descriptive error
3. Check .env.example - contains JIRA_BASE_URL documentation
4. Check docker-compose.yml - passes JIRA_BASE_URL to backend
5. Curl /api/config/jira - returns baseUrl configuration
</verification>

<success_criteria>
- Tempo sync extracts issue.key from API responses when available
- Issue keys display in "ABC-27 - Project Name" format
- Duplicate entries cause sync to fail with clear error message
- JIRA_BASE_URL configurable via environment variable
- API endpoint exposes Jira config to frontend
</success_criteria>

<output>
After completion, create `.planning/phases/03-data-quality-postgresql-migration/03-02-SUMMARY.md`
</output>
