---
phase: 07-foundation
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - backend/prisma/schema.prisma
  - backend/prisma/migrations/YYYYMMDD_add_utility_meters/migration.sql
  - backend/src/schemas/utility.schema.ts
autonomous: true

must_haves:
  truths:
    - "Meter and MeterReading tables exist in the database with correct columns and constraints"
    - "Monotonic validation trigger rejects readings that violate chronological ordering"
    - "One reading per meter per date is enforced at database level"
    - "Zod schemas validate meter and reading inputs with proper types and error messages"
  artifacts:
    - path: "backend/prisma/schema.prisma"
      provides: "Meter and MeterReading models"
      contains: "model Meter"
    - path: "backend/prisma/migrations/"
      provides: "Migration with monotonic trigger"
      contains: "check_meter_reading_monotonic"
    - path: "backend/src/schemas/utility.schema.ts"
      provides: "Zod validation schemas for meters and readings"
      exports: ["createMeterSchema", "updateMeterSchema", "createReadingSchema", "updateReadingSchema"]
  key_links:
    - from: "backend/prisma/schema.prisma"
      to: "PostgreSQL database"
      via: "prisma migrate deploy"
      pattern: "model Meter"
    - from: "backend/src/schemas/utility.schema.ts"
      to: "zod"
      via: "z.object imports"
      pattern: "import.*from.*zod"
---

<objective>
Create the database schema for utility meter tracking (Meter + MeterReading models) with a PostgreSQL monotonic validation trigger, and define Zod validation schemas for all API inputs.

Purpose: Establishes the data foundation that all other Phase 7 plans depend on. Without this, no API routes or UI can be built.
Output: Prisma models, database migration with trigger, and Zod validation schemas.
</objective>

<execution_context>
@/Users/vmiller/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vmiller/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-foundation/07-CONTEXT.md
@.planning/phases/07-foundation/07-RESEARCH.md
@backend/prisma/schema.prisma
@backend/src/schemas/estimate.schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add Meter and MeterReading Prisma models with monotonic trigger migration</name>
  <files>backend/prisma/schema.prisma, backend/prisma/migrations/YYYYMMDD_add_utility_meters/migration.sql</files>
  <action>
1. Add two new models to `backend/prisma/schema.prisma` (append after the existing EstimateProject model):

**Meter model:**
- `id`: String, @id, @default(dbgenerated("gen_random_uuid()")), @db.Uuid
- `type`: String (application-level enum: "STROM" | "GAS" | "WASSER_WARM" -- NOT a database enum, matches existing pattern where TimeEntry.source is a String)
- `name`: String (custom name, e.g. "Hauptzahler Keller")
- `unit`: String ("kWh" or "m3")
- `location`: String? (optional location description)
- `deletedAt`: DateTime? @db.Timestamptz(6) (soft delete -- LOCKED DECISION)
- `createdAt`: DateTime @default(now()) @db.Timestamptz(6)
- `updatedAt`: DateTime @updatedAt @db.Timestamptz(6)
- `readings`: MeterReading[] (relation)
- Indexes: @@index([type]), @@index([deletedAt])

**MeterReading model:**
- `id`: String, @id, @default(dbgenerated("gen_random_uuid()")), @db.Uuid
- `meterId`: String @db.Uuid
- `readingDate`: DateTime @db.Date (date only, no time needed)
- `value`: Float (raw meter value)
- `photoPath`: String? (path to uploaded photo)
- `notes`: String? (optional notes)
- `createdAt`: DateTime @default(now()) @db.Timestamptz(6)
- `meter`: Meter @relation(fields: [meterId], references: [id])
- Constraints: @@unique([meterId, readingDate]) (one reading per meter per date)
- Indexes: @@index([meterId, readingDate])

2. Create the migration using `--create-only` to get the SQL file without applying:
```bash
cd backend && npx prisma migrate dev --create-only --name add_utility_meters
```

3. Edit the generated migration SQL file to ADD the monotonic validation trigger AFTER the Prisma-generated CREATE TABLE statements. Append this SQL:

```sql
-- Monotonic validation trigger: ensures meter readings increase over time
CREATE OR REPLACE FUNCTION check_meter_reading_monotonic()
RETURNS TRIGGER AS $$
DECLARE
  prev_value FLOAT;
  next_value FLOAT;
BEGIN
  -- Find the most recent reading before this one for the same meter
  SELECT value INTO prev_value
  FROM "MeterReading"
  WHERE "meterId" = NEW."meterId"
    AND "readingDate" < NEW."readingDate"
    AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000')
  ORDER BY "readingDate" DESC
  LIMIT 1;

  -- If there's a previous reading and new value is less, reject
  IF prev_value IS NOT NULL AND NEW.value < prev_value THEN
    RAISE EXCEPTION 'Meter reading value (%) must be >= previous reading value (%)',
      NEW.value, prev_value;
  END IF;

  -- Also check that no future reading is less than this new value
  SELECT value INTO next_value
  FROM "MeterReading"
  WHERE "meterId" = NEW."meterId"
    AND "readingDate" > NEW."readingDate"
    AND id != COALESCE(NEW.id, '00000000-0000-0000-0000-000000000000')
  ORDER BY "readingDate" ASC
  LIMIT 1;

  IF next_value IS NOT NULL AND NEW.value > next_value THEN
    RAISE EXCEPTION 'Meter reading value (%) must be <= next reading value (%)',
      NEW.value, next_value;
  END IF;

  RETURN NEW;
END;
$$ LANGUAGE plpgsql;

CREATE TRIGGER enforce_monotonic_reading
  BEFORE INSERT OR UPDATE ON "MeterReading"
  FOR EACH ROW
  EXECUTE FUNCTION check_meter_reading_monotonic();
```

4. Apply the migration:
```bash
cd backend && npx prisma migrate dev
```

5. Generate the Prisma client:
```bash
cd backend && npx prisma generate
```
  </action>
  <verify>
Run `cd backend && npx prisma migrate status` -- should show all migrations applied with no pending.
Run `cd backend && npx prisma db execute --stdin <<< "SELECT column_name FROM information_schema.columns WHERE table_name = 'Meter';"` -- should list id, type, name, unit, location, deletedAt, createdAt, updatedAt.
Run `cd backend && npx prisma db execute --stdin <<< "SELECT tgname FROM pg_trigger WHERE tgrelid = '\"MeterReading\"'::regclass;"` -- should show enforce_monotonic_reading.
  </verify>
  <done>Meter and MeterReading tables exist in the database. Monotonic trigger is installed. Prisma client is generated with new model types available.</done>
</task>

<task type="auto">
  <name>Task 2: Create Zod validation schemas for meters and readings</name>
  <files>backend/src/schemas/utility.schema.ts</files>
  <action>
Create `backend/src/schemas/utility.schema.ts` following the pattern in `backend/src/schemas/estimate.schema.ts`.

Define these schemas:

**createMeterSchema:**
- `type`: z.enum(['STROM', 'GAS', 'WASSER_WARM'])
- `name`: z.string().min(1, 'Meter name is required').max(100)
- `unit`: z.string().min(1, 'Unit is required') -- will be 'kWh' or 'm3'
- `location`: z.string().max(200).optional()

**updateMeterSchema:**
- Same fields as createMeterSchema but all optional (for partial updates)

**createReadingSchema:**
- `meterId`: z.string().uuid('Invalid meter ID')
- `readingDate`: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be YYYY-MM-DD format')
- `value`: z.number().nonnegative('Reading value must be non-negative')
- `notes`: z.string().max(500).optional()

**updateReadingSchema:**
- `readingDate`: z.string().regex(/^\d{4}-\d{2}-\d{2}$/, 'Date must be YYYY-MM-DD format').optional()
- `value`: z.number().nonnegative('Reading value must be non-negative').optional()
- `notes`: z.string().max(500).nullable().optional()

Export all schemas AND their inferred types:
```typescript
export type CreateMeterInput = z.infer<typeof createMeterSchema>;
export type UpdateMeterInput = z.infer<typeof updateMeterSchema>;
export type CreateReadingInput = z.infer<typeof createReadingSchema>;
export type UpdateReadingInput = z.infer<typeof updateReadingSchema>;
```
  </action>
  <verify>
Run `cd backend && npx tsc --noEmit` -- should compile without errors.
Check that the file exports match the pattern in estimate.schema.ts (import z from 'zod', define schemas, export types).
  </verify>
  <done>All four Zod schemas (createMeter, updateMeter, createReading, updateReading) exist with proper validation rules and exported TypeScript types.</done>
</task>

</tasks>

<verification>
- `npx prisma migrate status` shows no pending migrations
- `npx tsc --noEmit` in backend compiles successfully
- Database has Meter and MeterReading tables with correct columns
- Monotonic trigger exists on MeterReading table
- Zod schemas export proper types
</verification>

<success_criteria>
- Meter and MeterReading models exist in Prisma schema with all specified fields
- Database migration applied successfully with monotonic trigger
- Unique constraint on [meterId, readingDate] enforced
- Zod schemas validate all input types with descriptive error messages
- TypeScript compiles without errors
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation/07-01-SUMMARY.md`
</output>
