---
phase: 07-foundation
plan: 03
type: execute
wave: 2
depends_on: ["07-01"]
files_modified:
  - backend/src/routes/utility.routes.ts
  - backend/src/server.ts
  - docker-compose.yml
  - docker/backend/Dockerfile
autonomous: true

must_haves:
  truths:
    - "GET /api/utilities/meters returns list of active (non-deleted) meters"
    - "POST /api/utilities/meters creates a new meter and returns 201"
    - "PUT /api/utilities/meters/:id updates a meter's fields"
    - "DELETE /api/utilities/meters/:id soft-deletes a meter (sets deletedAt)"
    - "POST /api/utilities/readings creates a reading with monotonic validation"
    - "GET /api/utilities/meters/:meterId/readings returns readings with on-demand consumption calculation"
    - "PUT /api/utilities/readings/:id updates a reading with monotonic re-validation"
    - "DELETE /api/utilities/readings/:id hard-deletes a reading"
    - "POST /api/utilities/readings/:id/photo uploads a photo to filesystem"
    - "All utility routes require JWT authentication"
  artifacts:
    - path: "backend/src/routes/utility.routes.ts"
      provides: "All utility CRUD endpoints"
      min_lines: 150
    - path: "backend/src/server.ts"
      provides: "Route registration within protected scope"
      contains: "utilityRoutes"
  key_links:
    - from: "backend/src/routes/utility.routes.ts"
      to: "backend/src/schemas/utility.schema.ts"
      via: "Zod schema imports for validation"
      pattern: "import.*from.*schemas/utility"
    - from: "backend/src/routes/utility.routes.ts"
      to: "@prisma/client"
      via: "PrismaClient for database operations"
      pattern: "prisma\\.meter\\."
    - from: "backend/src/server.ts"
      to: "backend/src/routes/utility.routes.ts"
      via: "protectedRoutes.register(utilityRoutes)"
      pattern: "register.*utilityRoutes"
    - from: "backend/src/routes/utility.routes.ts"
      to: "filesystem /uploads/meter-photos/"
      via: "file write for photo upload"
      pattern: "meter-photos"
---

<objective>
Build all backend API routes for utility meter CRUD, reading CRUD with on-demand consumption calculation, monotonic validation, photo upload, and configure Docker for file persistence.

Purpose: Provides the complete backend API that the frontend (Plan 04) will consume. All business logic for meters and readings lives here.
Output: Working API endpoints accessible at /api/utilities/* with proper authentication, validation, and data integrity.
</objective>

<execution_context>
@/Users/vmiller/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vmiller/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-foundation/07-CONTEXT.md
@.planning/phases/07-foundation/07-RESEARCH.md
@.planning/phases/07-foundation/07-01-SUMMARY.md
@backend/src/server.ts
@backend/src/routes/estimate.routes.ts
@backend/src/schemas/utility.schema.ts
@docker-compose.yml
@docker/backend/Dockerfile
</context>

<tasks>

<task type="auto">
  <name>Task 1: Install @fastify/static and create utility routes with all CRUD endpoints</name>
  <files>backend/src/routes/utility.routes.ts, backend/src/server.ts</files>
  <action>
**1. Install @fastify/static:**
```bash
cd backend && npm install @fastify/static
```

**2. Create `backend/src/routes/utility.routes.ts`:**

Follow the pattern in `estimate.routes.ts` (async function export, PrismaClient at module level, try/catch in each handler).

```typescript
import { FastifyInstance } from 'fastify';
import { PrismaClient } from '@prisma/client';
import fastifyStatic from '@fastify/static';
import path from 'path';
import fs from 'fs';
import {
  createMeterSchema,
  updateMeterSchema,
  createReadingSchema,
  updateReadingSchema,
} from '../schemas/utility.schema';

const prisma = new PrismaClient();
```

**Endpoints to implement:**

**GET /utilities/meters** - List all active meters
- Query: `prisma.meter.findMany({ where: { deletedAt: null }, orderBy: { createdAt: 'desc' }, include: { _count: { select: { readings: true } } } })`
- CRITICAL: Always filter `deletedAt: null` (soft delete filter -- see RESEARCH pitfall #2)
- Return meters with reading count

**POST /utilities/meters** - Create a meter
- Validate body with `createMeterSchema.parse(request.body)`
- Create with `prisma.meter.create({ data })`
- Return 201 with created meter
- Catch ZodError and return 400

**PUT /utilities/meters/:id** - Update a meter
- Validate body with `updateMeterSchema.parse(request.body)`
- Update with `prisma.meter.update({ where: { id }, data })`
- Return updated meter

**DELETE /utilities/meters/:id** - Soft delete a meter (LOCKED DECISION)
- Do NOT hard delete. Set `deletedAt: new Date()`:
```typescript
await prisma.meter.update({ where: { id }, data: { deletedAt: new Date() } });
```
- Return 204

**GET /utilities/meters/:meterId/readings** - Get readings with consumption
- Query readings ordered by `readingDate: 'asc'` (CRITICAL for correct consumption calculation -- see RESEARCH pitfall #3)
- Calculate consumption on-demand (LOCKED DECISION -- NOT stored):
```typescript
const readings = await prisma.meterReading.findMany({
  where: { meterId },
  orderBy: { readingDate: 'asc' },
  include: { meter: true },
});

const readingsWithConsumption = readings.map((reading, index) => ({
  id: reading.id,
  readingDate: reading.readingDate,
  value: reading.value,
  consumption: index === 0 ? null : reading.value - readings[index - 1].value,
  unit: reading.meter.unit,
  photoPath: reading.photoPath,
  notes: reading.notes,
  createdAt: reading.createdAt,
}));
```
- Return the array (display layer can reverse for desc order)

**POST /utilities/readings** - Create a reading
- Validate body with `createReadingSchema.parse(request.body)`
- **Application-level monotonic validation** (primary -- gives user-friendly errors):
  1. Check previous reading: `findFirst where meterId AND readingDate < new date, orderBy readingDate desc`
  2. If previousReading exists AND data.value < previousReading.value: return 400 with message "This reading is lower than your last one. Meter values can only increase." Include details: { previousValue, previousDate, attemptedValue }
  3. Check next reading: `findFirst where meterId AND readingDate > new date, orderBy readingDate asc`
  4. If nextReading exists AND data.value > nextReading.value: return 400 with message "This reading is higher than a later one. Meter values must increase over time." Include details: { nextValue, nextDate, attemptedValue }
- Create the reading (the database trigger is a safety net backup)
- Return 201

**PUT /utilities/readings/:id** - Update a reading
- Validate body with `updateReadingSchema.parse(request.body)`
- If value or readingDate changed, re-run monotonic validation (same logic as POST but exclude current reading by ID from the neighbor queries)
- Update with `prisma.meterReading.update`
- Return updated reading

**DELETE /utilities/readings/:id** - Delete a reading (hard delete -- readings are not soft-deleted, only meters are)
- `prisma.meterReading.delete({ where: { id } })`
- Return 204

**POST /utilities/readings/:id/photo** - Upload a photo
- Use `request.file()` (from @fastify/multipart, already registered)
- Validate mimetype is in ['image/jpeg', 'image/png', 'image/webp']
- Create uploads directory: `fs.mkdirSync(path.join(process.cwd(), 'uploads', 'meter-photos'), { recursive: true })`
- Save file as `${readingId}-${Date.now()}${ext}` to uploads/meter-photos/
- Update reading's photoPath to `/uploads/meter-photos/${filename}`
- Return { photoPath }

**Register @fastify/static** inside the utility routes plugin for serving uploaded photos:
```typescript
fastify.register(fastifyStatic, {
  root: path.join(process.cwd(), 'uploads'),
  prefix: '/uploads/',
  decorateReply: false, // Avoid decorator conflict if registered elsewhere
});
```
IMPORTANT: This is registered INSIDE the utility routes plugin which is INSIDE the protected routes scope, so photos require authentication (see RESEARCH pitfall #4).

**3. Register utility routes in `backend/src/server.ts`:**

Add import at the top:
```typescript
import { utilityRoutes } from './routes/utility.routes';
```

Register INSIDE the protectedRoutes plugin (around line 60, alongside estimateRoutes):
```typescript
protectedRoutes.register(utilityRoutes);
```

This ensures ALL utility routes require JWT authentication (NAV-02 requirement).
  </action>
  <verify>
Run `cd backend && npx tsc --noEmit` -- should compile without errors.
Start the backend with `cd backend && npm run dev` and test with curl:

```bash
# Get auth token first (adjust credentials)
TOKEN=$(curl -s -X POST http://localhost:3000/api/auth/login -H "Content-Type: application/json" -d '{"password":"your-password"}' | jq -r '.token // empty')

# If using cookie auth, use -b flag instead

# Test meters CRUD
curl -s http://localhost:3000/api/utilities/meters -H "Authorization: Bearer $TOKEN" | jq .
curl -s -X POST http://localhost:3000/api/utilities/meters -H "Authorization: Bearer $TOKEN" -H "Content-Type: application/json" -d '{"type":"STROM","name":"Hauptzahler","unit":"kWh"}' | jq .

# Test that endpoints exist (even if auth fails, should get 401 not 404)
curl -s -o /dev/null -w "%{http_code}" http://localhost:3000/api/utilities/meters
```

Without auth token, all /api/utilities/* endpoints should return 401 (not 404).
  </verify>
  <done>All 9 utility API endpoints exist and are functional: meters CRUD (4), readings CRUD (4), photo upload (1). All endpoints require authentication. Monotonic validation rejects invalid readings with user-friendly error messages. Consumption is calculated on-demand.</done>
</task>

<task type="auto">
  <name>Task 2: Configure Docker for file upload persistence</name>
  <files>docker-compose.yml, docker/backend/Dockerfile</files>
  <action>
**1. Update `docker/backend/Dockerfile`:**

After the existing line `RUN mkdir -p /app/cache && chown -R node:node /app` (line 77), add:
```dockerfile
RUN mkdir -p /app/uploads/meter-photos
```

The `chown -R node:node /app` on the same line already covers the new directory since it runs BEFORE the USER node directive.

**2. Update `docker-compose.yml`:**

Add a named volume for uploads and mount it to the backend service.

Under the `backend` service, add a `volumes` section:
```yaml
  backend:
    # ... existing config ...
    volumes:
      - uploads_data:/app/uploads
```

Under the top-level `volumes` section, add the new volume:
```yaml
volumes:
  postgres_data:
  uploads_data:
```

This ensures uploaded meter photos persist across container restarts and rebuilds.
  </action>
  <verify>
Run `docker compose config` from the project root -- should parse without errors and show the uploads_data volume.
Verify the Dockerfile builds: `docker compose build backend` (should succeed, no syntax errors).
  </verify>
  <done>Docker is configured to persist uploaded meter photos via a named volume. The uploads directory is created in the Dockerfile with correct ownership.</done>
</task>

</tasks>

<verification>
- `cd backend && npx tsc --noEmit` compiles successfully
- All 9 API endpoints return proper status codes
- Unauthenticated requests to /api/utilities/* return 401
- Monotonic validation rejects decreasing values with friendly error messages
- Soft delete sets deletedAt (does not remove row)
- Consumption calculation returns null for first reading and correct deltas for subsequent readings
- Docker compose config validates without errors
- Photo upload writes to /uploads/meter-photos/ directory
</verification>

<success_criteria>
- Complete CRUD for meters (create, list, update, soft-delete)
- Complete CRUD for readings (create, list-with-consumption, update, delete)
- Photo upload endpoint saves files and updates reading record
- All routes behind JWT authentication
- Monotonic validation at application level with user-friendly error messages
- On-demand consumption calculation (deltas not stored)
- Docker volume configured for upload persistence
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation/07-03-SUMMARY.md`
</output>
