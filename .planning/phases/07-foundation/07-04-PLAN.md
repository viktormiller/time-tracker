---
phase: 07-foundation
plan: 04
type: execute
wave: 3
depends_on: ["07-02", "07-03"]
files_modified:
  - frontend/src/pages/Utilities.tsx
  - frontend/src/components/utilities/MeterForm.tsx
  - frontend/src/components/utilities/ReadingForm.tsx
  - frontend/src/components/utilities/ReadingsTable.tsx
autonomous: false

must_haves:
  truths:
    - "User can create a meter via modal form with type, name, unit, and location fields"
    - "User can view meters in tabbed view, with readings listed in a sortable table"
    - "User can add a reading via modal form with meter selection, date picker, and value input"
    - "User can edit a meter (name, location) via the action menu"
    - "User can soft-delete a meter via the action menu with confirmation"
    - "User can edit a reading's date, value, and notes inline or via modal"
    - "User can delete a reading with confirmation"
    - "Readings table shows consumption column calculated on-demand (null for first reading)"
    - "Monotonic validation errors display inline in the reading form"
    - "Empty state transitions to meter view after first meter is created"
  artifacts:
    - path: "frontend/src/components/utilities/MeterForm.tsx"
      provides: "Modal form for creating and editing meters"
      min_lines: 80
    - path: "frontend/src/components/utilities/ReadingForm.tsx"
      provides: "Modal form for creating and editing readings"
      min_lines: 80
    - path: "frontend/src/components/utilities/ReadingsTable.tsx"
      provides: "Sortable table displaying readings with consumption"
      min_lines: 100
    - path: "frontend/src/pages/Utilities.tsx"
      provides: "Complete page with API integration and component orchestration"
      min_lines: 150
  key_links:
    - from: "frontend/src/pages/Utilities.tsx"
      to: "/api/utilities/meters"
      via: "axios.get for fetching meters"
      pattern: "axios\\.get.*utilities/meters"
    - from: "frontend/src/pages/Utilities.tsx"
      to: "/api/utilities/meters/:meterId/readings"
      via: "axios.get for fetching readings"
      pattern: "axios\\.get.*readings"
    - from: "frontend/src/components/utilities/MeterForm.tsx"
      to: "/api/utilities/meters"
      via: "axios.post/put for creating/updating meters"
      pattern: "axios\\.(post|put).*utilities/meters"
    - from: "frontend/src/components/utilities/ReadingForm.tsx"
      to: "/api/utilities/readings"
      via: "axios.post/put for creating/updating readings"
      pattern: "axios\\.(post|put).*utilities/readings"
    - from: "frontend/src/components/utilities/ReadingsTable.tsx"
      to: "frontend/src/pages/Utilities.tsx"
      via: "props: readings array, onEdit, onDelete callbacks"
      pattern: "ReadingsTable"
---

<objective>
Wire the frontend UI to the backend API with complete CRUD forms for meters and readings, a sortable readings table with consumption display, and full interactivity.

Purpose: This is the final plan that delivers the complete user-facing feature. After this plan, all Phase 7 success criteria are met: users can create meters, add/edit/delete readings, see consumption, and navigate to the Utilities section.
Output: Fully functional utilities section with CRUD operations, validation feedback, and data display.
</objective>

<execution_context>
@/Users/vmiller/.claude/get-shit-done/workflows/execute-plan.md
@/Users/vmiller/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/07-foundation/07-CONTEXT.md
@.planning/phases/07-foundation/07-RESEARCH.md
@.planning/phases/07-foundation/07-02-SUMMARY.md
@.planning/phases/07-foundation/07-03-SUMMARY.md
@frontend/src/pages/Utilities.tsx
@frontend/src/components/utilities/EmptyState.tsx
@frontend/src/components/utilities/MeterTabs.tsx
@frontend/src/pages/Estimates.tsx
@frontend/src/hooks/useToast.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MeterForm and ReadingForm modal components</name>
  <files>frontend/src/components/utilities/MeterForm.tsx, frontend/src/components/utilities/ReadingForm.tsx</files>
  <action>
**1. MeterForm.tsx** (`frontend/src/components/utilities/MeterForm.tsx`):

A modal form for creating and editing meters. Follow the modal pattern used in Estimates.tsx (overlay + centered card).

Props:
```typescript
interface MeterFormProps {
  meter?: Meter | null;  // null/undefined = create mode, object = edit mode
  onClose: () => void;
  onSave: () => void;    // callback to refresh data after save
}
```

Form fields:
- **Type**: Dropdown select with options: Strom (STROM), Gas (GAS), Wasser Warm (WASSER_WARM). Disabled in edit mode (can't change meter type after creation).
- **Name**: Text input, required, placeholder "z.B. Hauptzahler Keller"
- **Unit**: Auto-filled based on type selection (STROM -> "kWh", GAS -> "m3", WASSER_WARM -> "m3"). Show as read-only text or disabled input. Update automatically when type changes.
- **Location**: Text input, optional, placeholder "z.B. Keller, Hauswirtschaftsraum"

Behavior:
- In create mode: POST to `/api/utilities/meters`
- In edit mode: PUT to `/api/utilities/meters/${meter.id}`
- Show loading spinner on submit button while saving
- Show toast on success ("Zahler erstellt" / "Zahler aktualisiert")
- Show toast on error
- Close modal on successful save and call `onSave()`
- Use `useToast()` hook for notifications

Styling: Modal overlay (fixed inset-0, bg-black/50), centered card (bg-white dark:bg-gray-800, rounded-xl, shadow-xl, max-w-md). Matches existing modal patterns in the app.

**2. ReadingForm.tsx** (`frontend/src/components/utilities/ReadingForm.tsx`):

A modal form for creating and editing readings.

Props:
```typescript
interface ReadingFormProps {
  reading?: MeterReading | null;  // null = create mode
  meters: Meter[];                // for meter selection dropdown (create mode)
  selectedMeterId?: string;       // pre-selected meter (from active tab)
  onClose: () => void;
  onSave: () => void;
}
```

Form fields:
- **Meter**: Dropdown select showing meter name + type. Pre-selected if `selectedMeterId` provided. Disabled in edit mode.
- **Date**: Date input (type="date"), defaults to today. Format: YYYY-MM-DD.
- **Value**: Number input (type="number", step="0.01"), required. Placeholder shows unit from selected meter.
- **Notes**: Textarea, optional, placeholder "Optionale Notizen..."

Behavior:
- In create mode: POST to `/api/utilities/readings` with { meterId, readingDate, value, notes }
- In edit mode: PUT to `/api/utilities/readings/${reading.id}` with changed fields
- **Monotonic validation error handling**: If the API returns 400 with error "Invalid reading", display the error message INLINE below the value input field in red text. Do NOT just show a toast -- the user needs to see the specific validation context (previous value, attempted value). Show BOTH the toast AND inline error.
- Error message from API: "This reading is lower than your last one. Meter values can only increase." -- display this exactly as returned.
- Show loading spinner on submit
- Close modal on success, call onSave(), show toast
- Use `useToast()` hook

Styling: Same modal pattern as MeterForm.
  </action>
  <verify>
Run `cd frontend && npx tsc --noEmit` -- should compile (types need to match Meter/MeterReading interfaces in Utilities.tsx).
Verify both components export properly and can be imported from Utilities.tsx.
  </verify>
  <done>MeterForm renders create/edit modal with type, name, unit, location. ReadingForm renders create/edit modal with meter selection, date, value, notes. Monotonic validation errors display inline below value field.</done>
</task>

<task type="auto">
  <name>Task 2: Create ReadingsTable and wire everything together in Utilities.tsx</name>
  <files>frontend/src/components/utilities/ReadingsTable.tsx, frontend/src/pages/Utilities.tsx</files>
  <action>
**1. ReadingsTable.tsx** (`frontend/src/components/utilities/ReadingsTable.tsx`):

A sortable table displaying meter readings with on-demand consumption values.

Props:
```typescript
interface ReadingsTableProps {
  readings: MeterReading[];
  loading: boolean;
  onEdit: (reading: MeterReading) => void;
  onDelete: (readingId: string) => void;
}
```

Columns:
- **Datum** (Date): formatted as DD.MM.YYYY using date-fns `format(new Date(reading.readingDate), 'dd.MM.yyyy')`
- **Zahlerstand** (Meter Value): formatted with unit, e.g. "12,345.67 kWh"
- **Verbrauch** (Consumption): formatted with unit. Show "-" or "Basislinie" for null (first reading). Use green/normal coloring.
- **Notizen** (Notes): truncated if long, tooltip on hover
- **Aktionen** (Actions): kebab menu (three dots / MoreVertical icon) with Edit and Delete options

Sorting:
- Default sort: readingDate descending (newest first for display)
- Click column headers to toggle sort direction
- Sort indicator arrows on active column

Action menu:
- Use a simple dropdown (click to toggle, click outside to close)
- "Bearbeiten" (Edit) -- calls onEdit(reading)
- "Loschen" (Delete) -- shows confirmation dialog, then calls onDelete(readingId)

Empty state within table: "Noch keine Ablesungen vorhanden." (No readings yet.) -- shown when readings array is empty but we're not loading.

Loading state: Show skeleton rows (3 rows of gray animated bars) when loading is true.

Styling: Table with Tailwind classes matching the existing app's data display patterns. Alternating row colors, hover states, dark mode support. Responsive: on mobile, stack key fields or use horizontal scroll.

**2. Update Utilities.tsx** to orchestrate all components with real API calls:

Replace the placeholder state management with full API integration:

```typescript
// State
const [meters, setMeters] = useState<Meter[]>([]);
const [readings, setReadings] = useState<MeterReading[]>([]);
const [activeTab, setActiveTab] = useState<string>('STROM');
const [loading, setLoading] = useState(true);
const [readingsLoading, setReadingsLoading] = useState(false);
const [showMeterForm, setShowMeterForm] = useState(false);
const [showReadingForm, setShowReadingForm] = useState(false);
const [editingMeter, setEditingMeter] = useState<Meter | null>(null);
const [editingReading, setEditingReading] = useState<MeterReading | null>(null);
```

**API functions:**

`fetchMeters()`:
- GET `/api/utilities/meters`
- Set meters state
- Compute meter counts per type for MeterTabs
- If meters exist for the active tab, fetch readings for the first meter of that type
- If no meters exist at all, show EmptyState

`fetchReadings(meterId: string)`:
- GET `/api/utilities/meters/${meterId}/readings`
- Set readings state

`deleteMeter(id: string)`:
- Confirm with user: "Dieser Zahler wird archiviert. Alle Ablesungen bleiben erhalten." (This meter will be archived. All readings are preserved.)
- DELETE `/api/utilities/meters/${id}`
- Refresh meters, show toast

`deleteReading(id: string)`:
- Confirm with user: "Diese Ablesung wirklich loschen?" (Really delete this reading?)
- DELETE `/api/utilities/readings/${id}`
- Refresh readings, show toast

**useEffect hooks:**
- On mount: `fetchMeters()`
- On activeTab change: find meters of that type, fetch readings for the first one (or show "select a meter" if multiple)
- If only one meter per tab: auto-select it and show readings

**Layout with meters:**
- MeterTabs at top (with counts)
- Below tabs: if multiple meters of selected type, show a meter selector (simple dropdown or card list)
- Below meter selector: action bar with meter name, kebab menu (edit/delete meter), "Ablesung hinzufugen" (Add Reading) button
- Below action bar: ReadingsTable with readings for selected meter
- MeterForm modal (shown when showMeterForm or editingMeter)
- ReadingForm modal (shown when showReadingForm or editingReading)

**Meter action menu (kebab/...):**
- Per CONTEXT decision: "Action menu (kebab/...) for edit and delete operations"
- "Bearbeiten" (Edit) -> opens MeterForm in edit mode
- "Archivieren" (Archive) -> calls deleteMeter (soft delete)

**Flow after creating first meter:**
1. User sees EmptyState, clicks "Ersten Zahler erstellen"
2. MeterForm opens, user fills in type=STROM, name, unit auto-fills
3. On save, fetchMeters refreshes, meters.length > 0
4. EmptyState disappears, MeterTabs appear with the new meter
5. ReadingsTable shows empty state for readings
6. User clicks "Ablesung hinzufugen", ReadingForm opens with meter pre-selected
  </action>
  <verify>
Run `cd frontend && npx tsc --noEmit` -- compiles without errors.
Run `cd frontend && npm run build` -- builds successfully.

Manual verification (requires backend running):
1. Navigate to Utilities -- empty state appears
2. Create a meter -- tabs appear, meter selected
3. Add a reading -- appears in table with "-" consumption
4. Add a second reading (higher value) -- consumption shows delta
5. Try adding a reading with lower value -- inline error appears
6. Edit a reading -- form pre-fills, saves correctly
7. Delete a reading -- removed from table
8. Archive a meter -- disappears from list
  </verify>
  <done>ReadingsTable displays readings with consumption, sort, and action menus. Utilities.tsx orchestrates all components with real API calls. Full CRUD flow works: create meter -> add readings -> view consumption -> edit/delete. Monotonic validation errors shown inline.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Complete utility meter tracking feature: navigation integration, meter CRUD (create/edit/archive), reading CRUD (create/edit/delete), on-demand consumption calculation, monotonic validation with inline errors, photo upload endpoint, tabbed view by meter type, empty state with CTA.</what-built>
  <how-to-verify>
  1. Start the app (`cd backend && npm run dev` in one terminal, `cd frontend && npm run dev` in another)
  2. Log in and verify "Verbrauch" button appears in the navigation header
  3. Click "Verbrauch" -- should see empty state with illustration and "Ersten Zahler erstellen" button
  4. Create a Strom meter: click CTA, fill form (Type: Strom, Name: "Hauptzahler", Location: "Keller"), save
  5. Verify tabs appear with "Strom" active and the meter name displayed
  6. Add first reading: click "Ablesung hinzufugen", set date to 2024-01-15, value 10000, save
  7. Verify reading appears in table with consumption showing "-" or "Basislinie"
  8. Add second reading: date 2024-02-15, value 10350
  9. Verify consumption shows 350 kWh for the second reading
  10. Try adding a third reading: date 2024-03-15, value 10100 (LOWER than 10350)
  11. Verify inline error message appears: "This reading is lower than your last one..."
  12. Fix value to 10700, save -- should succeed, consumption shows 350 kWh
  13. Edit a reading -- verify form pre-fills correctly
  14. Delete a reading -- verify confirmation dialog and removal from table
  15. Archive the meter -- verify it disappears from the tab
  16. Toggle dark mode -- verify all utility components render correctly
  17. Click back arrow -- returns to dashboard
  </how-to-verify>
  <resume-signal>Type "approved" or describe any issues found</resume-signal>
</task>

</tasks>

<verification>
- `cd frontend && npm run build` succeeds with no TypeScript errors
- All CRUD operations work through the UI
- Consumption calculation displays correctly (null for first, delta for subsequent)
- Monotonic validation shows inline errors
- Tab navigation filters meters by type
- Empty state transitions to meter view after creation
- Dark mode works on all components
- Authentication required for all operations
</verification>

<success_criteria>
- User can create a meter (Strom/Gas/Wasser Warm) with name and unit [DATA-01]
- User can add a meter reading with date and value [DATA-02]
- User can edit an existing meter reading [DATA-03]
- User can delete a meter reading [DATA-04]
- App calculates consumption as delta between consecutive readings [DATA-05]
- App validates readings are monotonically increasing [DATA-06]
- User can navigate to Utilities from main navigation [NAV-01]
- Utilities shares authentication with time tracking [NAV-02]
- Utilities inherits dark mode / theme [NAV-03]
</success_criteria>

<output>
After completion, create `.planning/phases/07-foundation/07-04-SUMMARY.md`
</output>
