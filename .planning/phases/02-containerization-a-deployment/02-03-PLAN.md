---
phase: 02-containerization-a-deployment
plan: 03
type: execute
wave: 2
depends_on: ["02-01", "02-02"]
files_modified:
  - docker-compose.yml
  - docker-compose.prod.yml
  - docker/secrets/.gitkeep
  - scripts/generate-secrets.sh
  - .gitignore
autonomous: true
user_setup:
  - service: hetzner
    why: "Production deployment target"
    env_vars: []
    dashboard_config:
      - task: "Ensure Docker is installed on Hetzner server"
        location: "SSH to server: ssh root@your-server"

must_haves:
  truths:
    - "docker-compose up starts all three services"
    - "Services start in correct order (db -> backend -> frontend)"
    - "Database data persists across container restarts"
    - "Secrets are read from files, not environment variables"
  artifacts:
    - path: "docker-compose.yml"
      provides: "Development Docker Compose configuration"
      contains: "services:"
    - path: "docker-compose.prod.yml"
      provides: "Production Docker Compose overrides"
      contains: "secrets:"
    - path: "scripts/generate-secrets.sh"
      provides: "Secret generation script"
      contains: "openssl rand"
  key_links:
    - from: "docker-compose.yml"
      to: "docker/backend/Dockerfile"
      via: "build context reference"
      pattern: "context:.*backend"
    - from: "docker-compose.yml"
      to: "docker/frontend/Dockerfile"
      via: "build context reference"
      pattern: "context:.*frontend"
    - from: "backend service"
      to: "db service"
      via: "depends_on with health check"
      pattern: "condition: service_healthy"
---

<objective>
Create Docker Compose orchestration with health-based dependencies, secrets management, and development/production configurations.

Purpose: Enable the entire application stack to be launched with a single command, with proper service ordering, secret management via Docker Secrets, and separate configurations for development and production.

Output: docker-compose.yml (development), docker-compose.prod.yml (production overrides), secrets generation script
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-containerization-a-deployment/02-CONTEXT.md
@.planning/phases/02-containerization-a-deployment/02-RESEARCH.md

# Plans this depends on
@.planning/phases/02-containerization-a-deployment/02-01-PLAN.md
@.planning/phases/02-containerization-a-deployment/02-02-PLAN.md

# Key existing files
@backend/src/plugins/auth.ts (loadSecret function)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create development docker-compose.yml</name>
  <files>docker-compose.yml</files>
  <action>
Create docker-compose.yml with three services: db, backend, frontend.

```yaml
services:
  db:
    image: postgres:17-alpine
    restart: unless-stopped
    healthcheck:
      test: ["CMD-SHELL", "pg_isready -U timetracker -d timetracker"]
      interval: 10s
      timeout: 5s
      retries: 5
      start_period: 30s
    volumes:
      - postgres_data:/var/lib/postgresql/data
    environment:
      POSTGRES_USER: timetracker
      POSTGRES_PASSWORD: devpassword
      POSTGRES_DB: timetracker
    networks:
      - backend-network

  backend:
    build:
      context: ./backend
      dockerfile: ../docker/backend/Dockerfile
    restart: unless-stopped
    depends_on:
      db:
        condition: service_healthy
    healthcheck:
      test: ["CMD", "curl", "-f", "http://localhost:3000/health"]
      interval: 30s
      timeout: 10s
      retries: 3
      start_period: 40s
    environment:
      NODE_ENV: development
      DATABASE_URL: postgresql://timetracker:devpassword@db:5432/timetracker
      JWT_SECRET: dev-jwt-secret-must-be-at-least-32-characters-long
      SESSION_SECRET: dev-session-secret-32-chars-hex
      ADMIN_PASSWORD_HASH: "$2b$12$LQv3c1yqBWVHxkd0LHAkCOYz6TtxMQJqhN8/X4.G7o7G7o7G7o7G7"
      FRONTEND_URL: http://localhost
    networks:
      - backend-network
      - frontend-network

  frontend:
    build:
      context: ./frontend
      dockerfile: ../docker/frontend/Dockerfile
    restart: unless-stopped
    depends_on:
      backend:
        condition: service_healthy
    ports:
      - "80:80"
    networks:
      - frontend-network

volumes:
  postgres_data:

networks:
  backend-network:
    driver: bridge
  frontend-network:
    driver: bridge
```

Notes:
- Development uses hardcoded credentials (simpler for local dev)
- Backend connects to both networks (talks to db and serves frontend)
- Frontend only on frontend-network (can't access db directly)
- Only port 80 exposed (frontend), db and backend internal only
- Health checks ensure proper startup order
- ADMIN_PASSWORD_HASH is bcrypt hash - generate real one for actual use
  </action>
  <verify>
Run `docker-compose config` to validate YAML syntax
  </verify>
  <done>docker-compose.yml defines db, backend, frontend services with health-based dependencies</done>
</task>

<task type="auto">
  <name>Task 2: Create production docker-compose.prod.yml</name>
  <files>docker-compose.prod.yml</files>
  <action>
Create docker-compose.prod.yml as production overrides (used with `docker-compose -f docker-compose.yml -f docker-compose.prod.yml up`):

```yaml
services:
  db:
    environment:
      POSTGRES_PASSWORD_FILE: /run/secrets/db_password
    secrets:
      - db_password

  backend:
    environment:
      NODE_ENV: production
      DATABASE_URL: postgresql://timetracker:DOCKER-SECRET@db:5432/timetracker
    secrets:
      - jwt_secret
      - session_secret
      - admin_password_hash
      - db_password
    # Override to read db_password from secret at runtime
    command: >
      sh -c "
        DB_PASS=$$(cat /run/secrets/db_password) &&
        export DATABASE_URL=postgresql://timetracker:$$DB_PASS@db:5432/timetracker &&
        npx prisma migrate deploy &&
        node dist/server.js
      "

  frontend:
    ports:
      - "80:80"
      - "443:443"

secrets:
  jwt_secret:
    file: ./docker/secrets/jwt_secret
  session_secret:
    file: ./docker/secrets/session_secret
  admin_password_hash:
    file: ./docker/secrets/admin_password_hash
  db_password:
    file: ./docker/secrets/db_password
```

Notes:
- Production uses Docker Secrets (files in /run/secrets/)
- Backend already has loadSecret() function that reads from /run/secrets/
- Database password injected via shell command at runtime
- POSTGRES_PASSWORD_FILE is native PostgreSQL image feature
- Adds port 443 for future HTTPS support
  </action>
  <verify>
Run `docker-compose -f docker-compose.yml -f docker-compose.prod.yml config` to validate merged config
  </verify>
  <done>docker-compose.prod.yml uses Docker Secrets for all credentials</done>
</task>

<task type="auto">
  <name>Task 3: Create secrets generation script and directory</name>
  <files>scripts/generate-secrets.sh, docker/secrets/.gitkeep, .gitignore</files>
  <action>
1. Create docker/secrets/.gitkeep (empty file to keep directory in git)

2. Create scripts/generate-secrets.sh:
```bash
#!/bin/bash
# Generate production secrets for Docker deployment
# Run this once before first production deployment

set -e

SECRETS_DIR="docker/secrets"

# Create secrets directory if not exists
mkdir -p "$SECRETS_DIR"

echo "Generating production secrets..."

# JWT secret (64 bytes, base64 encoded)
openssl rand -base64 64 | tr -d '\n' > "$SECRETS_DIR/jwt_secret"
echo "Generated jwt_secret"

# Session secret (32 bytes, hex encoded for libsodium)
openssl rand -hex 32 > "$SECRETS_DIR/session_secret"
echo "Generated session_secret"

# Database password (32 random characters)
openssl rand -base64 32 | tr -d '\n' > "$SECRETS_DIR/db_password"
echo "Generated db_password"

# Admin password - prompt user
echo ""
echo "Enter admin password for login:"
read -s ADMIN_PASSWORD

if [ -z "$ADMIN_PASSWORD" ]; then
    echo "Error: Password cannot be empty"
    exit 1
fi

# Generate bcrypt hash using Node.js (bcrypt is already a dependency)
cd backend
HASH=$(node -e "require('bcrypt').hash('$ADMIN_PASSWORD', 12).then(h => console.log(h))")
cd ..
echo "$HASH" > "$SECRETS_DIR/admin_password_hash"
echo "Generated admin_password_hash"

# Secure file permissions
chmod 600 "$SECRETS_DIR"/*

echo ""
echo "Secrets generated successfully in $SECRETS_DIR/"
echo "IMPORTANT: Keep these files secure and never commit them to git!"
```

3. Update root .gitignore to add:
```
# Docker secrets (production credentials)
docker/secrets/*
!docker/secrets/.gitkeep
```

Make the script executable.
  </action>
  <verify>
1. `ls docker/secrets/.gitkeep` exists
2. `cat scripts/generate-secrets.sh` contains openssl commands
3. `grep -q "docker/secrets" .gitignore` returns true
  </verify>
  <done>Secret generation script created, docker/secrets directory gitignored except .gitkeep</done>
</task>

</tasks>

<verification>
1. `docker-compose config` validates successfully
2. `docker-compose -f docker-compose.yml -f docker-compose.prod.yml config` validates successfully
3. `scripts/generate-secrets.sh` is executable
4. `docker/secrets/` directory exists with .gitkeep
5. Root .gitignore excludes docker/secrets/* but keeps .gitkeep
</verification>

<success_criteria>
- docker-compose up -d starts all three services in correct order
- Services wait for health checks before dependent services start
- Development config uses environment variables for simplicity
- Production config uses Docker Secrets for all credentials
- Only port 80 exposed to host (database and backend internal only)
- Secret generation script creates all required secrets
</success_criteria>

<output>
After completion, create `.planning/phases/02-containerization-a-deployment/02-03-SUMMARY.md`
</output>
