---
phase: 02-containerization-a-deployment
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - docker/backend/Dockerfile
  - backend/src/server.ts
  - backend/prisma/schema.prisma
  - backend/.dockerignore
autonomous: true

must_haves:
  truths:
    - "Backend builds as Docker image without errors"
    - "Backend container exposes health check endpoint"
    - "Backend Prisma schema configured for PostgreSQL"
  artifacts:
    - path: "docker/backend/Dockerfile"
      provides: "Multi-stage backend Docker build"
      contains: "FROM node:22-slim"
    - path: "backend/src/server.ts"
      provides: "Health check endpoint"
      contains: "/health"
    - path: "backend/prisma/schema.prisma"
      provides: "PostgreSQL datasource configuration"
      contains: 'provider = "postgresql"'
    - path: "backend/.dockerignore"
      provides: "Build context exclusions"
      min_lines: 10
  key_links:
    - from: "docker/backend/Dockerfile"
      to: "backend/prisma/schema.prisma"
      via: "npx prisma generate in build stage"
      pattern: "prisma generate"
---

<objective>
Containerize the backend service with multi-stage Docker build, health endpoint, and PostgreSQL configuration.

Purpose: Enable the backend to run as a production-ready Docker container with proper health checks for orchestration and PostgreSQL support for production database.

Output: Backend Dockerfile, health endpoint in server.ts, PostgreSQL-ready Prisma schema, .dockerignore file
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-containerization-a-deployment/02-CONTEXT.md
@.planning/phases/02-containerization-a-deployment/02-RESEARCH.md

# Key existing files
@backend/src/server.ts
@backend/src/plugins/auth.ts
@backend/package.json
@backend/prisma/schema.prisma
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create backend Dockerfile with multi-stage build</name>
  <files>docker/backend/Dockerfile</files>
  <action>
Create multi-stage Dockerfile for backend:

**Stage 1 (builder):**
- Base: `node:22-slim` (NOT alpine - bcrypt has musl compatibility issues)
- WORKDIR /app
- Copy package*.json, run `npm ci`
- Copy all source files
- Run `npm run build` (tsc compilation)
- Run `npx prisma generate`

**Stage 2 (production):**
- Base: `node:22-slim`
- Install openssl (required for Prisma): `apt-get update && apt-get install -y openssl && rm -rf /var/lib/apt/lists/*`
- Create non-root user: `USER node`
- Copy from builder with `--chown=node:node`:
  - dist/ directory
  - node_modules/
  - prisma/ directory
  - package.json
- Set `NODE_ENV=production`
- EXPOSE 3000
- CMD: Run prisma migrate deploy first, then start server:
  `CMD ["sh", "-c", "npx prisma migrate deploy && node dist/server.js"]`

IMPORTANT: Use node:22-slim (Debian-based), NOT node:22-alpine. The project uses bcrypt@6.0.0 which has native bindings incompatible with Alpine's musl libc.
  </action>
  <verify>
Run `docker build -f docker/backend/Dockerfile -t time-tracker-backend ./backend` (may fail without PostgreSQL but should reach build stage)
  </verify>
  <done>Dockerfile exists at docker/backend/Dockerfile with multi-stage build using node:22-slim</done>
</task>

<task type="auto">
  <name>Task 2: Add health check endpoint to backend</name>
  <files>backend/src/server.ts</files>
  <action>
Add a `/health` endpoint to server.ts BEFORE the protected routes plugin registration.

The endpoint should:
1. Be a GET request to `/health` (no /api prefix, not protected)
2. Perform a basic database connectivity check: `await prisma.$queryRaw\`SELECT 1\``
3. Return 200 with `{ status: 'healthy', timestamp: new Date().toISOString() }` on success
4. Return 503 with `{ status: 'unhealthy', error: 'Database connection failed' }` on database error

Place this route AFTER CORS/multipart registration but BEFORE auth routes registration.

Example location in server.ts:
```typescript
// Health check endpoint (public, for Docker health checks)
app.get('/health', async (request, reply) => {
  try {
    await prisma.$queryRaw`SELECT 1`;
    return { status: 'healthy', timestamp: new Date().toISOString() };
  } catch (error) {
    reply.code(503).send({ status: 'unhealthy', error: 'Database connection failed' });
  }
});

// Auth routes (public - no authentication required)
app.register(authRoutes);
```
  </action>
  <verify>
Start backend locally with `cd /Users/vmiller/projects/time-tracker/backend && npm run dev`, then `curl http://localhost:3000/health` should return `{"status":"healthy",...}`
  </verify>
  <done>Health endpoint at /health returns status and performs database check</done>
</task>

<task type="auto">
  <name>Task 3: Configure Prisma schema for PostgreSQL</name>
  <files>backend/prisma/schema.prisma</files>
  <action>
Update Prisma schema to support PostgreSQL:

1. Change datasource provider from "sqlite" to "postgresql"
2. Change url from hardcoded file path to environment variable:
   `url = env("DATABASE_URL")`

The schema should look like:
```prisma
generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// Model definitions remain the same
model TimeEntry {
  id          String   @id @default(uuid())
  source      String
  externalId  String?
  date        DateTime
  duration    Float
  project     String?
  description String?
  createdAt   DateTime @default(now())

  @@unique([source, externalId])
  @@index([date])
}
```

NOTE: This change means local development will need DATABASE_URL set. For local dev, can use SQLite override or set up local PostgreSQL. The docker-compose will provide the correct PostgreSQL URL.
  </action>
  <verify>
Run `cd /Users/vmiller/projects/time-tracker/backend && npx prisma validate` - should pass without errors
  </verify>
  <done>Prisma schema uses postgresql provider with DATABASE_URL environment variable</done>
</task>

<task type="auto">
  <name>Task 4: Create backend .dockerignore</name>
  <files>backend/.dockerignore</files>
  <action>
Create .dockerignore file to exclude unnecessary files from Docker build context:

```
node_modules
npm-debug.log
.env
.env.*
.git
.gitignore
Dockerfile*
docker-compose*
.dockerignore
dist/
coverage/
logs/
*.log
.npmrc
.DS_Store
*.md
secrets/
toggl_cache.json
tempo_cache.json
dev.db
dev.db-journal
```

This excludes:
- node_modules (will be installed fresh in container)
- Environment files (secrets should come from Docker Secrets)
- Build artifacts (will be built in container)
- Cache files and SQLite database
- Development secrets directory
  </action>
  <verify>
File exists at backend/.dockerignore with appropriate exclusions
  </verify>
  <done>.dockerignore file excludes node_modules, .env files, cache files, and dev database</done>
</task>

</tasks>

<verification>
1. `docker build -f docker/backend/Dockerfile -t time-tracker-backend ./backend` completes build stage successfully
2. `curl http://localhost:3000/health` returns healthy status when backend running locally
3. `npx prisma validate` passes in backend directory
4. `backend/.dockerignore` contains all specified exclusions
</verification>

<success_criteria>
- Backend Dockerfile uses multi-stage build with node:22-slim base
- Health endpoint accessible at /health without authentication
- Prisma schema configured for PostgreSQL with DATABASE_URL
- .dockerignore excludes build artifacts, secrets, and cache files
</success_criteria>

<output>
After completion, create `.planning/phases/02-containerization-a-deployment/02-01-SUMMARY.md`
</output>
