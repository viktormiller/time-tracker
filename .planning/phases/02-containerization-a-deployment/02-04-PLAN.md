---
phase: 02-containerization-a-deployment
plan: 04
type: execute
wave: 3
depends_on: ["02-03"]
files_modified: []
autonomous: false

must_haves:
  truths:
    - "All three containers start and become healthy"
    - "Frontend accessible via browser at http://localhost"
    - "User can log in through the containerized application"
    - "API requests proxy correctly from frontend to backend"
    - "Database persists data across container restarts"
  artifacts: []
  key_links:
    - from: "browser"
      to: "frontend container"
      via: "http://localhost:80"
      pattern: "curl.*localhost"
    - from: "frontend container"
      to: "backend container"
      via: "nginx proxy to backend:3000"
      pattern: "/api/"
    - from: "backend container"
      to: "db container"
      via: "DATABASE_URL"
      pattern: "postgresql://.*@db:5432"
---

<objective>
Verify the complete Docker stack works end-to-end: containers start correctly, services communicate, authentication works, and data persists.

Purpose: Ensure the containerized application is production-ready before deployment to Hetzner.

Output: Verified working Docker stack, documented verification results
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/02-containerization-a-deployment/02-CONTEXT.md

# Prior plan summaries (if they exist)
@.planning/phases/02-containerization-a-deployment/02-01-SUMMARY.md
@.planning/phases/02-containerization-a-deployment/02-02-SUMMARY.md
@.planning/phases/02-containerization-a-deployment/02-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Build and start Docker stack</name>
  <files></files>
  <action>
Execute the following commands from project root:

1. Stop any running containers:
   `docker-compose down -v` (removes volumes for clean start)

2. Build all images:
   `docker-compose build`

3. Start all services in detached mode:
   `docker-compose up -d`

4. Wait for services to be healthy (up to 2 minutes):
   `docker-compose ps` - check all services show "healthy"

5. Check logs for any errors:
   `docker-compose logs --tail=50`

If services fail to start, check logs for specific service:
- `docker-compose logs db`
- `docker-compose logs backend`
- `docker-compose logs frontend`

Common issues to watch for:
- Database connection errors (backend before db healthy)
- Prisma migration failures
- Health check failures
  </action>
  <verify>
`docker-compose ps` shows all 3 services as "Up" with health status "healthy"
  </verify>
  <done>All three containers running and healthy</done>
</task>

<task type="auto">
  <name>Task 2: Verify service connectivity</name>
  <files></files>
  <action>
Test each connection point:

1. Frontend accessible:
   `curl -s -o /dev/null -w "%{http_code}" http://localhost`
   Should return 200

2. Health endpoint through nginx:
   `curl http://localhost/health`
   Should return `{"status":"healthy",...}`

3. API proxy working (will return 401 since not authenticated):
   `curl -s -o /dev/null -w "%{http_code}" http://localhost/api/stats`
   Should return 401 (proves proxy works, auth is enforced)

4. Auth endpoint accessible:
   `curl -X POST http://localhost/auth/login -H "Content-Type: application/json" -d '{"username":"admin","password":"wrong"}'`
   Should return 401 with error message (proves auth route accessible)

5. Database connectivity (via health endpoint):
   Health endpoint already checks database - if healthy, database works
  </action>
  <verify>
All curl commands return expected status codes (200, 401 as appropriate)
  </verify>
  <done>Frontend serves pages, API proxy works, auth endpoints accessible</done>
</task>

<task type="auto">
  <name>Task 3: Create test admin user and verify login</name>
  <files></files>
  <action>
The development docker-compose.yml has a placeholder ADMIN_PASSWORD_HASH. We need to:

1. Generate a bcrypt hash for a test password (e.g., "admin123"):
   ```bash
   docker-compose exec backend node -e "require('bcrypt').hash('admin123', 12).then(h => console.log(h))"
   ```

2. Update docker-compose.yml with the generated hash for ADMIN_PASSWORD_HASH

3. Restart backend to pick up new hash:
   `docker-compose restart backend`

4. Wait for backend to be healthy again:
   `docker-compose ps`

5. Test login:
   ```bash
   curl -X POST http://localhost/auth/login \
     -H "Content-Type: application/json" \
     -d '{"username":"admin","password":"admin123"}' \
     -c cookies.txt -v
   ```
   Should return 200 with access token and set refreshToken cookie

6. Test authenticated request:
   ```bash
   ACCESS_TOKEN=$(curl -s -X POST http://localhost/auth/login \
     -H "Content-Type: application/json" \
     -d '{"username":"admin","password":"admin123"}' | \
     grep -o '"accessToken":"[^"]*"' | cut -d'"' -f4)

   curl http://localhost/api/stats \
     -H "Authorization: Bearer $ACCESS_TOKEN"
   ```
   Should return 200 with empty array (no time entries yet)
  </action>
  <verify>
Login returns 200 with accessToken, authenticated /api/stats returns 200
  </verify>
  <done>Authentication flow works through containerized stack</done>
</task>

<task type="auto">
  <name>Task 4: Verify data persistence</name>
  <files></files>
  <action>
Test that PostgreSQL data survives container restarts:

1. Get access token (from Task 3)

2. Check current entry count (should be 0 or existing data):
   ```bash
   curl http://localhost/api/stats -H "Authorization: Bearer $ACCESS_TOKEN" | wc -l
   ```

3. The database should have the TimeEntry table. Verify via direct query:
   ```bash
   docker-compose exec db psql -U timetracker -d timetracker -c "\dt"
   ```
   Should show TimeEntry table (and Prisma migration table)

4. Restart all containers:
   `docker-compose restart`

5. Wait for healthy:
   `docker-compose ps`

6. Re-authenticate and check data still accessible:
   ```bash
   curl http://localhost/api/stats -H "Authorization: Bearer $(curl -s -X POST http://localhost/auth/login -H "Content-Type: application/json" -d '{"username":"admin","password":"admin123"}' | grep -o '"accessToken":"[^"]*"' | cut -d'"' -f4)"
   ```
   Should return same data (empty array or existing entries)

7. Verify volume exists:
   `docker volume ls | grep postgres_data`
  </action>
  <verify>
Data persists across container restart, postgres_data volume exists
  </verify>
  <done>PostgreSQL data persists in Docker volume across restarts</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Docker stack with:
- PostgreSQL database container with health checks
- Backend container with Prisma, auth, and API endpoints
- Frontend container with Nginx serving SPA and proxying API
- Docker Compose orchestration with proper dependencies
- Volume persistence for database
  </what-built>
  <how-to-verify>
1. Open http://localhost in your browser
2. You should see the login page
3. Log in with username "admin" and password "admin123"
4. Verify you see the dashboard (may be empty if no time entries)
5. Try refreshing the page - you should stay logged in
6. Check browser network tab: API calls should go to /api/* paths

Optional additional checks:
- Open browser dev tools, verify no CORS errors
- Check cookies: should have refreshToken httpOnly cookie
  </how-to-verify>
  <resume-signal>Type "verified" if the containerized app works correctly, or describe any issues encountered</resume-signal>
</task>

</tasks>

<verification>
1. `docker-compose ps` shows all 3 services healthy
2. `curl http://localhost` returns 200
3. `curl http://localhost/health` returns healthy status
4. Login flow works with test credentials
5. Data persists across container restarts
6. User confirms browser-based verification
</verification>

<success_criteria>
- All three containers start and become healthy within 2 minutes
- Frontend serves the React application at http://localhost
- API requests are proxied correctly through Nginx
- Authentication works end-to-end (login, protected routes, refresh)
- PostgreSQL data persists in Docker volume
- User verifies application works in browser
</success_criteria>

<output>
After completion, create `.planning/phases/02-containerization-a-deployment/02-04-SUMMARY.md`
</output>
