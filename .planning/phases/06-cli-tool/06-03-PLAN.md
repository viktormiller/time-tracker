---
phase: 06-cli-tool
plan: 03
type: execute
wave: 2
depends_on: ["06-02"]
files_modified:
  - cli/main.go
  - cli/go.mod
  - cli/go.sum
  - cli/cmd/root.go
  - cli/cmd/login.go
  - cli/internal/config/config.go
  - cli/internal/api/client.go
  - cli/internal/api/auth.go
  - cli/Makefile
autonomous: true

must_haves:
  truths:
    - "User can run `timetracker login` to authenticate with backend"
    - "Tokens are stored in ~/.timetracker/config.yaml with 0600 permissions"
    - "User can run `timetracker` to see available commands"
  artifacts:
    - path: "cli/main.go"
      provides: "CLI entry point"
      min_lines: 10
    - path: "cli/cmd/root.go"
      provides: "Root command with Viper config initialization"
      contains: "cobra.Command"
    - path: "cli/cmd/login.go"
      provides: "Login command"
      contains: "timetracker login"
    - path: "cli/internal/config/config.go"
      provides: "Config file management with secure permissions"
      contains: "0600"
    - path: "cli/internal/api/client.go"
      provides: "HTTP client with auth middleware"
      contains: "resty"
    - path: "cli/internal/api/auth.go"
      provides: "Authentication logic"
      contains: "cli-login"
  key_links:
    - from: "cli/cmd/login.go"
      to: "cli/internal/api/auth.go"
      via: "Login function call"
      pattern: "api\\.Login"
    - from: "cli/internal/api/auth.go"
      to: "/api/auth/cli-login"
      via: "HTTP POST request"
      pattern: "cli-login"
    - from: "cli/internal/api/auth.go"
      to: "cli/internal/config/config.go"
      via: "SaveConfig call"
      pattern: "config\\.Save"
---

<objective>
Create the Go CLI project structure with Cobra framework and implement the login command.

Purpose: Establish the CLI foundation that all commands will build on. The login command is the first user-facing feature because all other commands require authentication. This plan sets up the project structure, configuration management, and authentication flow.

Output: A working `timetracker login` command that authenticates with the backend and stores tokens securely.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-cli-tool/06-RESEARCH.md
@.planning/phases/06-cli-tool/06-02-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Initialize Go module and create project structure</name>
  <files>cli/main.go, cli/go.mod, cli/cmd/root.go, cli/internal/config/config.go, cli/Makefile</files>
  <action>
1. Create cli/ directory in project root.

2. Initialize Go module:
```bash
cd cli
go mod init timetracker-cli
```

3. Install dependencies:
```bash
go get github.com/spf13/cobra@latest
go get github.com/spf13/viper@latest
go get github.com/go-resty/resty/v2@latest
go get github.com/fatih/color@latest
go get gopkg.in/yaml.v3@latest
```

4. Create cli/main.go:
```go
package main

import "timetracker-cli/cmd"

func main() {
    cmd.Execute()
}
```

5. Create cli/cmd/root.go:
- Define rootCmd with Use: "timetracker", Short: "CLI for time tracking"
- Implement Execute() function that calls rootCmd.Execute()
- Implement init() with cobra.OnInitialize(initConfig)
- Add --config flag for custom config file path
- initConfig function:
  - If cfgFile set, use it directly with viper.SetConfigFile()
  - Otherwise: config dir is ~/.timetracker/, config file is config.yaml
  - Create config dir with 0700 permissions if not exists
  - viper.SetConfigType("yaml")
  - viper.AutomaticEnv() with prefix "TIMETRACKER"
  - viper.ReadInConfig() (ignore error if file doesn't exist)

6. Create cli/internal/config/config.go:
- Package config
- Function Save() that writes current viper config to ~/.timetracker/config.yaml
- Use yaml.v3 to marshal config
- Create directory with os.MkdirAll(dir, 0700)
- Write file with os.WriteFile(path, data, 0600) for secure permissions
- Function GetConfigPath() returns full path to config file
- Function EnsureConfigDir() creates config directory if needed

7. Create cli/Makefile:
```makefile
.PHONY: build install clean test

BINARY=timetracker
VERSION?=0.1.0

build:
	go build -ldflags "-X main.version=$(VERSION)" -o $(BINARY) .

install: build
	cp $(BINARY) $(GOPATH)/bin/$(BINARY) || cp $(BINARY) ~/go/bin/$(BINARY)

clean:
	rm -f $(BINARY)

test:
	go test ./...
```

8. Verify build:
```bash
cd cli && go build -o timetracker . && ./timetracker --help
```
  </action>
  <verify>
- `cd cli && go build -o timetracker .` succeeds
- `./timetracker --help` shows usage with "CLI for time tracking"
- `ls -la ~/.timetracker/` creates directory with drwx------ permissions (if run once)
  </verify>
  <done>
- Go module initialized with all dependencies
- Project structure follows standard Cobra layout
- Root command works and shows help
- Config directory created with secure permissions
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement API client and login command</name>
  <files>cli/internal/api/client.go, cli/internal/api/auth.go, cli/cmd/login.go</files>
  <action>
1. Create cli/internal/api/client.go:
- Package api
- Function NewClient() returns *resty.Client
- Configure base URL from viper.GetString("api_url") with default "http://localhost:3000"
- Set Content-Type header to application/json
- Add OnBeforeRequest middleware that:
  - Gets access_token from viper
  - If token exists, sets Authorization header with Bearer token
  - (Token refresh will be added in next plan)

2. Create cli/internal/api/auth.go:
- Package api
- Define response types:
  ```go
  type LoginResponse struct {
      AccessToken  string `json:"accessToken"`
      RefreshToken string `json:"refreshToken"`
      ExpiresIn    int    `json:"expiresIn"`
  }
  ```
- Function Login(username, password string) error:
  - Create new resty client (not using NewClient - no auth needed for login)
  - Set base URL from viper
  - POST to /api/auth/cli-login with credentials
  - Check response status (401 = invalid credentials, other errors)
  - On success: store tokens in viper and call config.Save()
  - viper.Set("access_token", result.AccessToken)
  - viper.Set("refresh_token", result.RefreshToken)

3. Create cli/cmd/login.go:
- Define loginCmd with Use: "login", Short: "Authenticate with the time tracker API"
- RunE function:
  - Prompt for username (use fmt.Print + fmt.Scanln, or accept --username flag)
  - Prompt for password (use golang.org/x/term for hidden input if available, or warn user)
  - Call api.Login(username, password)
  - On success: print "Login successful! Tokens stored in ~/.timetracker/config.yaml"
  - On failure: print error and return error for non-zero exit code
- Add flags: --username, --password (optional, for scripting)
- In init(): rootCmd.AddCommand(loginCmd)

4. Add x/term for password masking:
```bash
cd cli && go get golang.org/x/term@latest
```

5. Test login flow:
```bash
cd cli && go build -o timetracker .
./timetracker login --username admin --password YOUR_PASSWORD
cat ~/.timetracker/config.yaml
```
Should show api_url, access_token, refresh_token in config file.

6. Verify file permissions:
```bash
ls -la ~/.timetracker/config.yaml
```
Should show -rw------- (0600)
  </action>
  <verify>
- `./timetracker login` prompts for credentials
- Successful login stores tokens in ~/.timetracker/config.yaml
- Config file has 0600 permissions
- Invalid credentials return error message
  </verify>
  <done>
- API client exists with base URL configuration
- Login command prompts for credentials or accepts flags
- Tokens stored securely in config file
- Error messages are user-friendly
  </done>
</task>

</tasks>

<verification>
Complete login flow test:

1. Build CLI:
```bash
cd cli && go build -o timetracker .
```

2. Test help:
```bash
./timetracker --help
# Should show available commands including 'login'
```

3. Test login with bad credentials:
```bash
./timetracker login --username admin --password wrong
# Should show authentication error
```

4. Test login with good credentials:
```bash
./timetracker login --username admin --password YOUR_PASSWORD
# Should show success message
```

5. Verify config file:
```bash
cat ~/.timetracker/config.yaml
# Should contain access_token and refresh_token
stat -f "%Lp" ~/.timetracker/config.yaml  # macOS
# Should show 600
```

6. Test config persistence:
```bash
./timetracker login --username admin --password YOUR_PASSWORD
# Login again - should work and update tokens
```
</verification>

<success_criteria>
- [ ] cli/ directory exists with proper Go module structure
- [ ] `go build` produces working binary
- [ ] `timetracker --help` shows available commands
- [ ] `timetracker login` prompts for credentials
- [ ] Successful login stores tokens in ~/.timetracker/config.yaml
- [ ] Config file has 0600 permissions (only owner can read/write)
- [ ] Config directory has 0700 permissions
- [ ] Invalid credentials return clear error message
- [ ] --username and --password flags work for scripting
</success_criteria>

<output>
After completion, create `.planning/phases/06-cli-tool/06-03-SUMMARY.md`
</output>
