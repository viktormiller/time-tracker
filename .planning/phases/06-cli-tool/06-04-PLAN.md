---
phase: 06-cli-tool
plan: 04
type: execute
wave: 2
depends_on: ["06-01", "06-03"]
files_modified:
  - cli/cmd/today.go
  - cli/cmd/week.go
  - cli/cmd/sync.go
  - cli/internal/api/client.go
  - cli/internal/api/auth.go
  - cli/internal/api/types.go
  - cli/internal/display/table.go
autonomous: true

must_haves:
  truths:
    - "User can run `timetracker today` to see today's hours"
    - "User can run `timetracker week` to see weekly breakdown as ASCII table"
    - "User can run `timetracker sync` to trigger backend sync with progress indicator"
    - "Commands automatically refresh token if expired"
  artifacts:
    - path: "cli/cmd/today.go"
      provides: "Today command"
      contains: "summary/today"
    - path: "cli/cmd/week.go"
      provides: "Week command"
      contains: "summary/week"
    - path: "cli/cmd/sync.go"
      provides: "Sync command"
      contains: "/api/sync"
    - path: "cli/internal/api/types.go"
      provides: "API response types"
      contains: "TodaySummary"
    - path: "cli/internal/display/table.go"
      provides: "ASCII table formatting"
      contains: "tablewriter"
  key_links:
    - from: "cli/cmd/today.go"
      to: "/api/entries/summary/today"
      via: "GET request"
      pattern: "summary/today"
    - from: "cli/cmd/week.go"
      to: "/api/entries/summary/week"
      via: "GET request"
      pattern: "summary/week"
    - from: "cli/cmd/sync.go"
      to: "/api/sync"
      via: "POST request"
      pattern: "POST.*api/sync"
    - from: "cli/internal/api/client.go"
      to: "/api/auth/cli-refresh"
      via: "Token refresh middleware"
      pattern: "cli-refresh"
---

<objective>
Implement the three core CLI commands: today, week, and sync.

Purpose: These are the primary user-facing features of the CLI. Users can quickly check their worked hours from the terminal without opening a browser. The sync command enables users to trigger data refresh from time tracking sources.

Output: Three working commands that display time data and trigger sync operations with proper formatting and error handling.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-cli-tool/06-RESEARCH.md
@.planning/phases/06-cli-tool/06-01-SUMMARY.md
@.planning/phases/06-cli-tool/06-03-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add token refresh and API types</name>
  <files>cli/internal/api/client.go, cli/internal/api/auth.go, cli/internal/api/types.go</files>
  <action>
1. Create cli/internal/api/types.go with response structs:
```go
package api

type TodaySummary struct {
    Date       string        `json:"date"`
    TotalHours float64       `json:"totalHours"`
    BySource   []SourceHours `json:"bySource"`
}

type SourceHours struct {
    Name  string  `json:"name"`
    Hours float64 `json:"hours"`
}

type WeekSummary struct {
    StartDate  string        `json:"startDate"`
    EndDate    string        `json:"endDate"`
    TotalHours float64       `json:"totalHours"`
    ByDay      []DayHours    `json:"byDay"`
    BySource   []SourceHours `json:"bySource"`
}

type DayHours struct {
    Date  string  `json:"date"`
    Hours float64 `json:"hours"`
}

type SyncResult struct {
    NewEntries int              `json:"newEntries"`
    Updated    int              `json:"updated"`
    Errors     int              `json:"errors"`
    Providers  []ProviderResult `json:"providers"`
}

type ProviderResult struct {
    Name    string `json:"name"`
    Status  string `json:"status"`
    Entries int    `json:"entries"`
    Message string `json:"message,omitempty"`
}
```

2. Update cli/internal/api/auth.go to add RefreshToken function:
```go
func RefreshToken() error {
    refreshToken := viper.GetString("refresh_token")
    if refreshToken == "" {
        return fmt.Errorf("no refresh token found, please login")
    }

    client := resty.New().SetBaseURL(viper.GetString("api_url"))
    var result LoginResponse

    resp, err := client.R().
        SetHeader("Content-Type", "application/json").
        SetBody(map[string]string{"refreshToken": refreshToken}).
        SetResult(&result).
        Post("/api/auth/cli-refresh")

    if err != nil {
        return fmt.Errorf("connection failed: %w", err)
    }

    if resp.StatusCode() == 401 {
        return fmt.Errorf("session expired, please login again")
    }

    if resp.StatusCode() != 200 {
        return fmt.Errorf("refresh failed: %s", resp.String())
    }

    viper.Set("access_token", result.AccessToken)
    viper.Set("refresh_token", result.RefreshToken)
    return config.Save()
}
```

3. Update cli/internal/api/client.go NewClient() to add token refresh in OnBeforeRequest:
- Check if access_token is empty or expired
- If expired, call RefreshToken()
- If refresh fails with 401, return error prompting re-login
- Set Authorization header with updated token

Add helper function to check token expiry by decoding JWT (or simple time-based check using stored expiry time).

For simplicity, store expiry time in config when receiving token:
```go
// In auth.go Login() and RefreshToken():
viper.Set("token_expires_at", time.Now().Add(time.Duration(result.ExpiresIn)*time.Second).Unix())
```

Then in client.go check:
```go
expiresAt := viper.GetInt64("token_expires_at")
if expiresAt > 0 && time.Now().Unix() > expiresAt-60 { // 60 second buffer
    if err := RefreshToken(); err != nil {
        return err
    }
}
```
  </action>
  <verify>
`cd cli && go build -o timetracker .` succeeds with new types
  </verify>
  <done>
- API types defined for all endpoint responses
- Token refresh function implemented
- Client middleware refreshes token before requests
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement today, week, and sync commands</name>
  <files>cli/cmd/today.go, cli/cmd/week.go, cli/cmd/sync.go, cli/internal/display/table.go</files>
  <action>
1. Install additional dependencies:
```bash
cd cli
go get github.com/olekukonko/tablewriter@latest
go get github.com/briandowns/spinner@latest
```

2. Create cli/internal/display/table.go:
```go
package display

import (
    "os"
    "github.com/olekukonko/tablewriter"
)

func RenderTable(headers []string, data [][]string) {
    table := tablewriter.NewWriter(os.Stdout)
    table.SetHeader(headers)
    table.SetBorder(true)
    table.SetRowLine(false)
    table.SetAlignment(tablewriter.ALIGN_LEFT)
    table.AppendBulk(data)
    table.Render()
}
```

3. Create cli/cmd/today.go:
- Define todayCmd with Use: "today", Short: "Show today's worked hours"
- RunE function:
  - Call api.NewClient().R().SetResult(&summary).Get("/api/entries/summary/today")
  - Handle 401 (print "Not authenticated. Run: timetracker login")
  - Print date header
  - Print total hours with color (green for positive, yellow for 0)
  - Print breakdown by source using simple fmt.Printf formatting
- In init(): rootCmd.AddCommand(todayCmd)

Output format:
```
Today: 2026-01-22

Total: 6.5 hours

By Source:
  TOGGL:    4.0 hours
  TEMPO:    2.0 hours
  MANUAL:   0.5 hours
```

4. Create cli/cmd/week.go:
- Define weekCmd with Use: "week", Short: "Show weekly summary"
- RunE function:
  - Call api.NewClient().R().SetResult(&summary).Get("/api/entries/summary/week")
  - Handle errors
  - Print week date range
  - Print total hours
  - Use display.RenderTable for daily breakdown (Day | Hours)
  - Print source breakdown below table
- In init(): rootCmd.AddCommand(weekCmd)

Output format:
```
Week: 2026-01-20 to 2026-01-26

Total: 38.5 hours

+------------+-------+
|    DAY     | HOURS |
+------------+-------+
| Mon 01-20  |  8.0  |
| Tue 01-21  |  7.5  |
| Wed 01-22  |  6.5  |
| Thu 01-23  |  0.0  |
| Fri 01-24  |  0.0  |
| Sat 01-25  |  0.0  |
| Sun 01-26  |  0.0  |
+------------+-------+

By Source:
  TOGGL:   20.0 hours
  TEMPO:   15.0 hours
  MANUAL:   3.5 hours
```

5. Create cli/cmd/sync.go:
- Define syncCmd with Use: "sync", Short: "Sync time entries from all sources"
- RunE function:
  - Start spinner with "Syncing time entries..."
  - Set longer timeout (60 seconds) for sync request
  - Call api.NewClient().R().SetResult(&result).SetTimeout(60*time.Second).Post("/api/sync")
  - Stop spinner
  - On success: print green "Sync complete!"
  - Print summary: new entries, updated, errors
  - Print per-provider results
- In init(): rootCmd.AddCommand(syncCmd)

Output format:
```
Syncing time entries... done

Sync complete!
  New entries: 5
  Updated: 2
  Errors: 0

Provider Results:
  TOGGL:  success (3 entries)
  TEMPO:  success (2 entries)
```

6. Build and test all commands:
```bash
cd cli && go build -o timetracker .
./timetracker today
./timetracker week
./timetracker sync
```
  </action>
  <verify>
- `./timetracker today` shows today's hours
- `./timetracker week` shows ASCII table with weekly breakdown
- `./timetracker sync` shows spinner then results
- All commands handle 401 gracefully
  </verify>
  <done>
- Today command shows total hours and source breakdown
- Week command displays ASCII table with daily hours
- Sync command shows progress spinner and results
- All commands use consistent error handling
  </done>
</task>

<task type="auto">
  <name>Task 3: End-to-end verification and Makefile update</name>
  <files>cli/Makefile</files>
  <action>
1. Update cli/Makefile to add install target that copies to /usr/local/bin:
```makefile
.PHONY: build install clean test

BINARY=timetracker
VERSION?=0.1.0

build:
	go build -ldflags "-X main.version=$(VERSION)" -o $(BINARY) .

install: build
	sudo cp $(BINARY) /usr/local/bin/$(BINARY)

install-user: build
	mkdir -p ~/bin
	cp $(BINARY) ~/bin/$(BINARY)

clean:
	rm -f $(BINARY)

test:
	go test ./...

uninstall:
	sudo rm -f /usr/local/bin/$(BINARY)
```

2. Run complete verification flow:

```bash
# Build
cd cli && make build

# Login
./timetracker login --username admin --password YOUR_PASSWORD

# Check today
./timetracker today

# Check week
./timetracker week

# Trigger sync
./timetracker sync

# Check again after sync
./timetracker today
```

3. Test token refresh:
```bash
# Manually expire token by editing config
# ~/.timetracker/config.yaml - set token_expires_at to past timestamp

# Run command - should auto-refresh
./timetracker today
# Should work without prompting for login
```

4. Test error cases:
```bash
# Remove config file
rm ~/.timetracker/config.yaml

# Try command without login
./timetracker today
# Should show: "Not authenticated. Run: timetracker login"
```

5. Optionally install globally:
```bash
make install
# Now can run from anywhere:
timetracker today
```
  </action>
  <verify>
- Full flow works: login -> today -> week -> sync
- Token auto-refresh works when token expires
- Clear error messages for unauthenticated users
- Optional: `timetracker` available globally after `make install`
  </verify>
  <done>
- Complete CLI tool working end-to-end
- All three commands functional: today, week, sync
- Token refresh transparent to user
- Installation via Makefile
  </done>
</task>

</tasks>

<verification>
Complete end-to-end test of all CLI functionality:

1. Fresh start:
```bash
rm -rf ~/.timetracker
cd cli && go build -o timetracker .
```

2. Test without auth:
```bash
./timetracker today
# Expected: "Not authenticated. Run: timetracker login"
```

3. Login:
```bash
./timetracker login --username admin --password YOUR_PASSWORD
# Expected: "Login successful!"
```

4. Today command:
```bash
./timetracker today
# Expected: Shows today's date, total hours, breakdown by source
```

5. Week command:
```bash
./timetracker week
# Expected: Shows week range, ASCII table with 7 days, source breakdown
```

6. Sync command:
```bash
./timetracker sync
# Expected: Spinner -> "Sync complete!" -> summary
```

7. Verify config security:
```bash
ls -la ~/.timetracker/
# Expected: drwx------ (700)
ls -la ~/.timetracker/config.yaml
# Expected: -rw------- (600)
```

8. Verify help:
```bash
./timetracker --help
# Expected: Shows all commands: login, today, week, sync
```
</verification>

<success_criteria>
- [ ] `timetracker today` shows today's hours with source breakdown
- [ ] `timetracker week` shows ASCII table with Mon-Sun breakdown
- [ ] `timetracker sync` shows spinner during sync and summary after
- [ ] Token auto-refresh works transparently
- [ ] 401 errors prompt user to login
- [ ] Makefile has build/install/clean targets
- [ ] All commands have proper --help text
- [ ] Config file permissions are secure (0600)
</success_criteria>

<output>
After completion, create `.planning/phases/06-cli-tool/06-04-SUMMARY.md`
</output>
